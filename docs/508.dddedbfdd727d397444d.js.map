{"version":3,"file":"508.dddedbfdd727d397444d.js","mappings":"8OAgDAA,OAAOC,eAAe,2BAAkC,gBAAiB,CACrEC,IAAK,WACD,OAAOC,KAAKC,cAChB,EACAC,IAAK,SAAwCC,G,QACzCH,KAAKC,eAAiBE,EACI,QAA1B,EAAW,QAAX,EAAAH,KAAKI,cAAM,eAAEC,qBAAa,SAAEC,wBAChC,EACAC,YAAY,EACZC,cAAc,IAQX,MAAMC,EA8BTC,YAAYC,GACRX,KAAKI,OAASO,EACdX,KAAKY,QAAUD,EAAME,YACrBb,KAAKc,wBAA0B,KAC/Bd,KAAKe,eAAiB,GACtBf,KAAKgB,iBAAmB,GACxBhB,KAAKiB,SAAW,IAAIC,IAEpBT,EAAcU,8BAA8BnB,KAAKI,QAEjDJ,KAAKc,wBAA0Bd,KAAKY,QAAQQ,mBAAmBC,KAC3D,KACIrB,KAAKsB,aAAa,IAI1BtB,KAAKM,wBACT,CAzBWiB,oBACP,OAAOvB,KAAKe,cAChB,CAEWS,sBACP,OAAOxB,KAAKgB,gBAChB,CAqBOS,WACHzB,KAAK0B,wBACL1B,KAAKsB,aACT,CAEOK,kCACHC,GAEA,MAAMC,EAAQ7B,KAAK8B,wBAAwBF,GAC3C,OAAkB,IAAXC,EAAe7B,KAAKe,eAAec,GAAS,IACvD,CAEOE,gCACHC,GAEA,MAAMH,EAAQ7B,KAAKiC,sBAAsBD,GACzC,OAAkB,IAAXH,EAAe7B,KAAKe,eAAec,GAAS,IACvD,CAEOK,kBACHN,EACAO,EACAC,EACAC,GAEA,MAAMC,EAAS,IAAI,EAAAC,mCAAmCvC,KAAKI,OAAQwB,GAEnEU,EAAOE,sBAAsBnB,IACzBrB,KAAKyC,iCAAiCC,KAAK1C,OAG1CoC,IACDA,EAAiB,IAAI,EAAAO,6BACjB3C,KAAKI,OACLiC,GAEJrC,KAAKgB,iBAAiB4B,KAAKR,IAG1BA,EAAeS,qBAAqBC,gBACrCV,EAAeS,qBAAqBxB,IAChCrB,KAAK+C,+BAA+BL,KAAK1C,YAIlBgD,IAA3Bb,IACAC,EAAeD,uBAAyBA,GAG5C,MAAMc,EAAe,CAAEX,SAAQF,kBAQ/B,OANApC,KAAKe,eAAe6B,KAAKK,GAEzBjD,KAAK0B,wBAEL1B,KAAKyC,mCAEEQ,CACX,CAEOC,gBACHC,EACAC,EACAjB,EACAC,EACAC,GAEA,MAAMC,EAAS,IAAI,EAAAe,iCACfrD,KAAKI,OACL+C,EACAC,GAGJd,EAAOE,sBAAsBnB,IACzBrB,KAAKyC,iCAAiCC,KAAK1C,OAG1CoC,IACDA,EAAiB,IAAI,EAAAO,6BACjB3C,KAAKI,OACLiC,GAEJrC,KAAKgB,iBAAiB4B,KAAKR,IAG1BA,EAAeS,qBAAqBC,gBACrCV,EAAeS,qBAAqBxB,IAChCrB,KAAK+C,+BAA+BL,KAAK1C,YAIlBgD,IAA3Bb,IACAC,EAAeD,uBAAyBA,GAG5C,MAAMc,EAAe,CAAEX,SAAQF,kBAQ/B,OANApC,KAAKe,eAAe6B,KAAKK,GAEzBjD,KAAK0B,wBAEL1B,KAAKyC,mCAEEQ,CACX,CAEOK,mBACHL,EACAM,GAA6B,GAE7B,MAAM1B,EAAQ7B,KAAKe,eAAeyC,QAAQP,GAC1C,OAAe,IAAXpB,IAIJoB,EAAaX,OAAOmB,UAEpBzD,KAAKe,eAAe2C,OAAO7B,EAAO,GAE9B0B,GAA8BvD,KAAK2D,+BACnC3D,KAAKsB,cAELtB,KAAKyC,oCAGF,EACX,CAEQf,wBACJ1B,KAAKe,eAAe6C,MAAK,CAACC,EAAGC,IAClBD,EAAEvB,OAAOyB,SAAWD,EAAExB,OAAOyB,UAC7B,EACDF,EAAEvB,OAAOyB,SAAWD,EAAExB,OAAOyB,SAC7B,EACA,GAEd,CAEOzD,yBACH,IAAK,IAAI0D,EAAI,EAAGA,EAAIhE,KAAKI,OAAO6D,gBAAgBC,SAAUF,EAAG,CACzD,MAAMpC,EAAK5B,KAAKI,OAAO6D,gBAAgBD,GACjCnC,EAAQ7B,KAAK8B,wBAAwBF,IAC5B,IAAXC,EAEID,EAAGuC,eACmB,mBAAtBvC,EAAGwC,gBAEHpE,KAAKkC,kBAAkBN,GAA8B,GAEjDA,EAAGuC,gBACXnE,KAAKe,eAAec,GAAOS,OAAOmB,UAClCzD,KAAKe,eAAe2C,OAAO7B,EAAO,G,CAG1C7B,KAAK2D,+BACL3D,KAAKsB,aACT,CAEQqC,+BACJ,MAAMU,EAAqC,CAAC,EAE5C,IAAK,IAAIL,EAAI,EAAGA,EAAIhE,KAAKe,eAAemD,SAAUF,EAAG,CACjD,MAAM5B,EAAiBpC,KAAKe,eAAeiD,GAAG5B,eAC9CiC,EAAQrE,KAAKgB,iBAAiBwC,QAAQpB,KAAmB,C,CAG7D,IAAIkC,GAAU,EACd,MAAMC,EAA+C,GACrD,IAAK,IAAIP,EAAI,EAAGA,EAAIhE,KAAKgB,iBAAiBkD,SAAUF,EAC3CK,EAAQL,GAITO,EAAQ3B,KAAK5C,KAAKgB,iBAAiBgD,KAHnChE,KAAKgB,iBAAiBgD,GAAGP,UACzBa,GAAU,GAWlB,OALIA,IACAtE,KAAKgB,iBAAiBkD,OAAS,EAC/BlE,KAAKgB,iBAAiB4B,QAAQ2B,IAG3BD,CACX,CAEQE,+BACJC,GAEA,QAAUA,EAA2CC,cACzD,CAEQF,6BACJC,GAEA,MAEI,qCADCA,EAAyCL,cAGlD,CAEQtC,wBAAwBF,GAC5B,IAAK,IAAIoC,EAAI,EAAGA,EAAIhE,KAAKe,eAAemD,SAAUF,EAAG,CACjD,MAAMS,EAAMzE,KAAKe,eAAeiD,GAAG1B,OACnC,GACI7B,EAAckE,wBAAwBF,IACtCA,EAAIC,iBAAmB9C,EAEvB,OAAOoC,C,CAIf,OAAQ,CACZ,CAEQ/B,sBAAsBD,GAC1B,IAAK,IAAIgC,EAAI,EAAGA,EAAIhE,KAAKe,eAAemD,SAAUF,EAAG,CACjD,MAAMS,EAAMzE,KAAKe,eAAeiD,GAAG1B,OACnC,GACI7B,EAAcmE,sBAAsBH,IACpCA,EAAItB,cAAc,+BAAuCnB,EAEzD,OAAOgC,C,CAIf,OAAQ,CACZ,CAEQ1C,cACJ,IAAK,IAAI0C,EAAI,EAAGA,EAAIhE,KAAKgB,iBAAiBkD,SAAUF,EAChDhE,KAAKgB,iBAAiBgD,GAAGP,UAG7B,MAAMoB,EAMF,IAAI3D,IAER,IAAK,IAAI8C,EAAI,EAAGA,EAAIhE,KAAKgB,iBAAiBkD,SAAUF,EAAG,CACnD,MAAM5B,EAAiBpC,KAAKgB,iBAAiBgD,GAI7C,GAFA5B,EAAe0C,aAEX1C,EAAeC,QAAUD,EAAe2C,kBAAmB,CAC3D,IAAIC,EAAOH,EAAQ9E,IAAIqC,EAAeC,QACjC2C,IACDA,EAAO,CAAC,GAAI,CAAC,GACbH,EAAQ3E,IAAIkC,EAAeC,OAAQ2C,IAEvCA,EAAK,GAAGpC,KAAKR,GACbA,EAAeC,OAAO4C,kBAClB7C,EAAe2C,kBACff,E,EAKZ,IAAK,MAAO3B,EAAQ2C,KAASH,EAAS,CAClC,MAAMK,EAAmB7C,EAAO8C,uBAChC,IAAKD,EACD,SAGJ,MAAO1D,EAAiB4D,GAAqBJ,EAE7CE,EAAiBG,wBAAwBhE,KAAI,K,MACpC6D,EAAiBI,aAAaC,qBAC/BL,EAAiBI,aAAaE,0BAC1B,GACA,EACAxF,KAAKY,QAAQ6E,gBACbjE,EAAgB,GAAGkE,SAG3B,IAAK,MAAMtD,KAAkBZ,EAAiB,CAC1C,MAAMmE,EACkC,QAApC,EAAAvD,EAAewD,6BAAqB,eAAEC,aACpCC,EAAmBH,aAAW,EAAXA,EAAaI,QACtC,GAAIJ,GAAeG,EAAkB,CACjC,MAAME,EACFF,EAAiBG,MACjB,IACAH,EAAiBI,OACrB,IAAIC,EAAmBf,EAAkBY,GACpCG,IACDA,EAAmBf,EAAkBY,GACjC,IAAI,EAAAI,iBACApG,KAAKY,QACLkF,EAAiBG,MACjBH,EAAiBI,SAG7BC,EAAiBE,eAAeC,YAC5BX,E,MAQpB,IAAK,MAAOtD,EAAQ2C,KAAShF,KAAKiB,SAAU,CACxC,MAAMmE,EAAoBJ,EAAK,GAEzBuB,EAAQ1B,EAAQ9E,IAAIsC,GAC1B,GAAKkE,EAKD,IAAK,MAAMP,KAAOZ,EACTmB,EAAM,GAAGP,IACVZ,EAAkBY,GAAKvC,eAN/B,IAAK,MAAMuC,KAAOZ,EACdA,EAAkBY,GAAKvC,S,CAWnCzD,KAAKiB,SAASuF,QACdxG,KAAKiB,SAAW4D,EAEhB7E,KAAKyC,kCACT,CAEQA,mCACJ,MAAMgE,EAAgB,IAAIvF,IAE1B,IAAK,IAAI8C,EAAI,EAAGA,EAAIhE,KAAKe,eAAemD,SAAUF,EAAG,CACjD,MAAM0C,EAAkB1G,KAAKe,eAAeiD,GAC5C,IAAI2C,EAAUF,EAAc1G,IAAI2G,EAAgBtE,qBAChCY,IAAZ2D,IACAA,EAAU,GAEdF,EAAcvG,IACVwG,EAAgBtE,eAChBwE,KAAKC,IAAIF,EAASD,EAAgBpE,OAAOwE,c,CAIjD,IAAK,MAAO1E,EAAgB0E,KAAiBL,EACrCrE,EAAe2E,oBACf3E,EAAe2E,kBAAkBD,aAAeA,EAG5D,CAEQ/D,iCACJ,IAAK,IAAIiB,EAAI,EAAGA,EAAIhE,KAAKe,eAAemD,SAAUF,EAAG,CACjD,MAAM0C,EAAkB1G,KAAKe,eAAeiD,GAC5C0C,EAAgBpE,OAAO0E,YACnBN,EAAgBtE,eAAe4E,W,CAE3C,CAGOC,oBACH,IAAIC,GAAqB,EACzB,IAAK,IAAIlD,EAAI,EAAGA,EAAIhE,KAAKgB,iBAAiBkD,SAAUF,EAChDkD,EACIA,GACAlH,KAAKgB,iBAAiBgD,GAAGkD,mBAE7BA,GACAlH,KAAKsB,aAEb,CAGO6F,QAAQC,G,MACX,IAAK,IAAIpD,EAAI,EAAGA,EAAIhE,KAAKgB,iBAAiBkD,SAAUF,EAC3CoD,GAAapH,KAAKgB,iBAAiBgD,GAAG3B,SAAW+E,GAClDpH,KAAKgB,iBAAiBgD,GAAGqD,eAIjC,IAAK,MAAOhF,EAAQ2C,KAAShF,KAAKiB,SAAU,CACxC,GAAImG,GAAa/E,IAAW+E,EACxB,SAGJ,MAAMlC,EAAmB7C,EAAO8C,uBAChC,IAAKD,EACD,SAGJ,MAAMoC,EAC2B,QAA7B,EAAApC,EAAiBI,oBAAY,eAAEC,oBACnC,GAAI+B,EAAiB,CACjB,MAAO9F,EAAiB4D,GAAqBJ,EAC7C,IAAK,MAAM5C,KAAkBZ,EACzBY,EAAemF,gBAAkBD,EAErC,IAAK,MAAMtB,KAAOZ,EACdA,EAAkBY,GAAKwB,KAAKF,E,EAKxC,IAAK,IAAItD,EAAI,EAAGA,EAAIhE,KAAKe,eAAemD,SAAUF,EAAG,CACjD,MAAM0C,EAAkB1G,KAAKe,eAAeiD,GAEvCoD,GACDV,EAAgBtE,eAAeC,SAAW+E,GAE1CV,EAAgBtE,eAAeqF,OAAOf,EAAgBpE,O,CAGlE,CAEOmB,UACHzD,KAAKY,QAAQQ,mBAAmBsG,OAAO1H,KAAKc,yBAC5Cd,KAAKc,wBAA0B,KAE/B,IAAK,IAAIkD,EAAI,EAAGA,EAAIhE,KAAKe,eAAemD,SAAUF,EAC9ChE,KAAKe,eAAeiD,GAAG1B,OAAOmB,UAGlC,IAAK,IAAIO,EAAI,EAAGA,EAAIhE,KAAKgB,iBAAiBkD,SAAUF,EAChDhE,KAAKgB,iBAAiBgD,GAAGP,UAG7B,IAAK,MAAMuC,KAAOhG,KAAKiB,SAAU,CAC7B,MAAMmE,EAAoBY,EAAI,GAAG,GACjC,IAAK,MAAMA,KAAOZ,EACdA,EAAkBY,GAAKvC,S,CAI/BzD,KAAKe,eAAiB,GACtBf,KAAKgB,iBAAmB,GACxBhB,KAAKiB,SAASuF,OAClB,EAjec,EAAArF,8BACV,KACI,KAAM,6GAA6G,EAke/H,0DCviBA,yqBDyiBA,4DEziBA,yxBF4iBA,8DG5iBA,iaH8iBA,gEI9iBA,iTJijBA,4DKjjBA,mfLmjBA,8DMnjBA,mRNsjBA,uDOtjBA,qwCPyjBA,sDQzjBA,4uBR4jBA,qDS5jBA,ykLT8jBA,yDU9jBA,qiNVikBA,iDWjkBA,2LXkkBA,mDYlkBA,qIZokBA,qDapkBA,iPbskBA,uDctkBA,4PdykBA,uDezkBA,sa,0ECEO,MAAewG,EAwDlBjH,YACIC,EACgBwC,EACAyE,GADA,KAAAzE,cAAAA,EACA,KAAAyE,YAAAA,EApDb,KAAA7D,SAAW,EAER,KAAA8D,cAAgB,GAEnB,KAAArF,sBACH,IAAI,aAeD,KAAAsF,uBAAyB,IAMxB,KAAAC,cAAe,EA4BnB/H,KAAKI,OAASO,EACdX,KAAKY,QAAUD,EAAME,YACrBb,KAAKgI,kBAAmB,EACxBhI,KAAKiI,oBAAsB,KAC3BjI,KAAKkI,wBAA0B,IACnC,CApDWpB,mBACP,OAAO9G,KAAK6H,aAChB,CAEWf,iBAAaqB,GAChBA,IAASnI,KAAK6H,gBAIlB7H,KAAK6H,cAAgBM,EACrBnI,KAAKwC,sBAAsB4F,gBAAgBpI,MAC/C,CAIWqI,oBACP,OAAQrI,KAAK4H,WACjB,CAIWZ,kBACP,OAAOhH,KAAK+H,YAChB,CAEWf,gBAAYsB,GACftI,KAAK+H,eAAiBO,GAAQtI,KAAKuI,iBAIvCvI,KAAK+H,aAAeO,EACpBtI,KAAKgI,kBAAmB,EAC5B,CAEQO,eACJ,QAASvI,KAAKmD,cAAcqF,QAChC,CAEOpE,eACH,MAAO,sBACX,CAcUqE,iBACN,MAAMC,EAAe,CAAC,OAAQ,aAAc,iBAAkB,QACxDC,EAAiB,CAAC,WAAY,UAC9BC,EAAoB,GAE1B5I,KAAKgI,kBAAmB,EAEpBhI,KAAKgH,cACL2B,EAAe/F,KAAK,YACpBgG,EAAQhG,KAAK,oCAGjB5C,KAAKiI,oBAAsB,IAAI,gBAAsB,CACjDY,OAAQ7I,KAAKY,QACbkI,gBAAgB,EAChBC,aAAc,qBACdC,eAAgB,qBAChBL,iBACAD,eACAO,aAAc,GACdL,YAGJF,EAAa9F,KAAK,iBAElB5C,KAAKkI,wBAA0B,IAAI,gBAAsB,CACrDW,OAAQ7I,KAAKY,QACbkI,gBAAgB,EAChBC,aAAc,yBACdC,eAAgB,yBAChBL,eAAgB,CAAC,WAAY,UAC7BD,eACAO,aAAc,IAEtB,CAEOC,UAKH,GAJIlJ,KAAKgI,kBACLhI,KAAKyI,kBAGJzI,KAAKiI,sBAAwBjI,KAAKkI,wBACnC,OAAO,EAGX,MAAMiB,EAAcnJ,KAAKiI,oBAAoBmB,aAAaC,OACpDC,EACFtJ,KAAKkI,wBAAwBkB,aAAaC,OAE9C,OAAOF,EAAYD,WAAaI,EAAgBJ,SACpD,CAEO9F,eACH,OAAO,CACX,CAEOmG,qBACH,MAAMnG,EAAepD,KAAKoD,eAE1B,IAAKpD,KAAKiI,qBAAwC,IAAjB7E,EAC7B,OAGJ,MAAMoG,EAAmBxJ,KAAKiI,oBAAoBmB,aAC5CD,EAAcK,EAAiBH,OAErCrJ,KAAKY,QAAQ6I,aAAaD,GAC1BxJ,KAAKY,QAAQ8I,YACT1J,KAAKmD,cACLnD,KAAK4H,YACLuB,GAGJA,EAAYQ,UAAU,OAAQ3J,KAAKI,OAAOwJ,iBAC1CT,EAAYQ,UAAU,aAAc3J,KAAKI,OAAOyJ,uBAChDV,EAAYW,UAAU,OAAQ9J,KAAK6H,cAAe7H,KAAK6H,eACvDsB,EAAYY,SAAS,iBAAkB/J,KAAK6H,cAAgB,GAExD7H,KAAKqI,cACLrI,KAAKY,QAAQoJ,eACT,2CACA,EACA,EACA5G,GAGJpD,KAAKY,QAAQqJ,iBACT,sCACA,EACA7G,EAGZ,CAEO8G,yBACH,MAAM9G,EAAepD,KAAKoD,eAE1B,IAAKpD,KAAKkI,yBAA4C,IAAjB9E,EACjC,OAGJ,MAAM+G,EAAuBnK,KAAKkI,wBAAwBkB,aACpDE,EAAkBa,EAAqBd,OAE7CrJ,KAAKY,QAAQwJ,aAAa,0BAC1BpK,KAAKY,QAAQyJ,eAAc,GAE3BrK,KAAKY,QAAQ6I,aAAaU,GAC1BnK,KAAKY,QAAQ8I,YACT1J,KAAKmD,cACLnD,KAAK4H,YACL0B,GAGJA,EAAgBK,UAAU,OAAQ3J,KAAKI,OAAOwJ,iBAC9CN,EAAgBK,UACZ,aACA3J,KAAKI,OAAOyJ,uBAEhBP,EAAgBS,SAAS,gBAAiB/J,KAAK8H,wBAC/CwB,EAAgBQ,UACZ,OACA9J,KAAK6H,cACL7H,KAAK6H,eAGL7H,KAAKqI,cACLrI,KAAKY,QAAQoJ,eACT,2CACA,EACA,EACA5G,GAGJpD,KAAKY,QAAQqJ,iBACT,sCACA,EACA7G,GAIRpD,KAAKY,QAAQyJ,eAAc,GAC3BrK,KAAKY,QAAQwJ,aAAa,0BAC9B,CAEOE,uBAEP,CAEO7G,U,QACqB,QAAxB,EAAAzD,KAAKiI,2BAAmB,SAAExE,UACE,QAA5B,EAAAzD,KAAKkI,+BAAuB,SAAEzE,SAClC,E,kGC1NG,MAAMlB,UAA2C,EAAAoF,qBA4CpDjH,YAAYC,EAAsBiB,GAC9B2I,MACI5J,EACAiB,EAAGuB,cACHvB,EAAGgG,aAhCH,KAAA4C,oCAAqC,EAmCzCxK,KAAKyK,gBAAkB7I,EAEvB5B,KAAK0K,gBAAkB9I,EAAG6F,OAAO/E,KAAKd,GACtC5B,KAAK2K,WAAa/I,EAAGgJ,UACrB5K,KAAK6K,8BAAgC,KAErCjJ,EAAG6F,OAAS,IAAM,EAElBzH,KAAK8G,cAAgBlF,EAAGkJ,QAAUlJ,EAAGmJ,SAAW,EAEhD/K,KAAKgL,mCAAoC,CAC7C,CAtDWtG,qBACP,OAAO1E,KAAKyK,eAChB,CAEOrG,eACH,MAAO,oCACX,CAIW4G,wCACP,OAAOhL,KAAKwK,kCAChB,CAEWQ,sCAAkC1C,GACrCtI,KAAKwK,qCAAuClC,IAIhDtI,KAAKwK,mCAAqClC,EAEtCA,GACAtI,KAAKyK,gBAAgBG,UAAY5K,KAAK2K,WACtC3K,KAAKyK,gBAAgBQ,gCAAgCvD,OACjD1H,KAAK6K,+BAET7K,KAAK6K,8BAAgC,OAErC7K,KAAKyK,gBAAgBG,WAAa,EAClC5K,KAAK6K,8BACD7K,KAAKyK,gBAAgBQ,gCAAgC5J,KAAI,KACrDrB,KAAKY,QAAQwJ,aAAa,0BAAgC,KAG1E,CAsBOlB,UACH,OAAOqB,MAAMrB,WAAalJ,KAAKyK,gBAAgBvB,SACnD,CAEO9F,eACH,OAAOpD,KAAKyK,gBAAgBS,gBAChC,CAEOZ,uBACHtK,KAAK0K,iBACT,CAEOjH,UACH8G,MAAM9G,UAENzD,KAAKyK,gBAAgBQ,gCAAgCvD,OACjD1H,KAAK6K,+BAET7K,KAAK6K,8BAAgC,KACrC7K,KAAKyK,gBAAgBhD,OAASzH,KAAK0K,gBACnC1K,KAAKyK,gBAAgBG,UAAY5K,KAAK2K,UAC1C,E,gGCrFG,MAAMtH,UAAyC,EAAAsE,qBASlDjH,YACIC,EACAwC,EACAC,GAEAmH,MAAM5J,EAAOwC,EAAe,MAE5BnD,KAAKmL,cAAgB/H,EACrBpD,KAAKoL,kBAAmB,EACxBpL,KAAKqL,sBAAwB,KAExBlI,EAAsB,SACvBA,EAAsB,OAAI,IAAI,eAC1BnD,KAAKY,QACL,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,EAAG,GACtB,UACA,GACA,EACA,GAEJZ,KAAKoL,kBAAmB,EAEhC,CA1BOhH,eACH,MAAO,kCACX,CA0BUqE,iBACN8B,MAAM9B,iBAKNzI,KAAKqL,sBAAwB,IAAI,gBAAsB,CACnDxC,OAAQ7I,KAAKY,QACbkI,gBAAgB,EAChBC,aAAc,uBACdC,eAAgB,uBAChBL,eAPmB,CAAC,WAAY,SAAU,SAQ1CD,aATiB,CAAC,OAAQ,aAAc,QAUxCO,aAAc,IAEtB,CAEOC,U,QACH,OACIqB,MAAMrB,WACwC,QAA7C,EAA0B,QAA1B,EAAAlJ,KAAKqL,6BAAqB,eAAEhC,OAAQH,iBAAS,QAEtD,CAEO9F,eACH,OAAOpD,KAAKmL,aAChB,CAEOG,gBAAgBC,GACnBvL,KAAKmL,cAAgBI,CACzB,CAEOjB,uBACH,MAAMlH,EAAepD,KAAKoD,eAE1B,IAAKpD,KAAKqL,uBAA0C,IAAjBjI,EAC/B,OAGJ,MAAMoI,EAAqBxL,KAAKqL,sBAAsBjC,aAChDqC,EAAgBD,EAAmBnC,OAEzCrJ,KAAKY,QAAQ6I,aAAa+B,GAC1BxL,KAAKY,QAAQ8I,YACT1J,KAAKmD,cACLnD,KAAK4H,YACL6D,GAGJA,EAAc9B,UAAU,OAAQ3J,KAAKI,OAAOwJ,iBAC5C6B,EAAc9B,UACV,aACA3J,KAAKI,OAAOyJ,uBAEW,OAAvB7J,KAAK6H,eACL4D,EAAc3B,UACV,OACA9J,KAAK6H,cACL7H,KAAK6H,eAIT7H,KAAKqI,cACLrI,KAAKY,QAAQoJ,eACT,2CACA,EACA,EACA5G,GAGJpD,KAAKY,QAAQqJ,iBACT,sCACA,EACA7G,EAGZ,CAEOK,U,MACH8G,MAAM9G,UAEoB,QAA1B,EAAAzD,KAAKqL,6BAAqB,SAAE5H,UAExBzD,KAAKoL,kBACLpL,KAAKmD,cAAsB,OAAEM,SAErC,E,qECzHG,MAAM2C,EAeT1F,YAAYmI,EAAwB5C,EAAeC,GAV3C,KAAAwF,eAEJ,CAAC,EASD1L,KAAKY,QAAUiI,EACf7I,KAAK2L,OAAS1F,EACdjG,KAAK4L,QAAU1F,EAEflG,KAAK6L,gBAAkB7L,KAAKY,QAAQkL,0BAChC,CAAE7F,QAAOC,UACT,CACI6F,iBAAiB,EACjBC,KAAM,sCACNC,OAAQ,4BACRC,aAAc,yCACdC,qBAAqB,EACrBC,uBAAuB,EACvB1G,QAAS,EACT2G,eAAe,IAGvBrM,KAAK6L,gBAAgBrG,0BAA0B,GAAG,GAAO,EAAO,GAEhExF,KAAKsM,mBAAqB,IAAI,gBAAsB,CAChDzD,OAAQ7I,KAAKY,QACbkI,gBAAgB,EAChBC,aAAc,YACdC,eAAgB,YAChBL,eAAgB,CAAC,YACjBD,aAAc,GACdO,aAAc,CAAC,gBACfsD,eAAgB1D,EAAO2D,SACjB,sBACA,wBAIV,MAAMC,EAAW,GACjBA,EAAS7J,KAAK,EAAG,GACjB6J,EAAS7J,MAAM,EAAG,GAClB6J,EAAS7J,MAAM,GAAI,GACnB6J,EAAS7J,KAAK,GAAI,GAElB5C,KAAK0L,eAAe,6BAChB,IAAI,eACA1L,KAAKY,QACL6L,EACA,6BACA,GACA,EACA,GAIR,MAAMC,EAAU,GAChBA,EAAQ9J,KAAK,GACb8J,EAAQ9J,KAAK,GACb8J,EAAQ9J,KAAK,GAEb8J,EAAQ9J,KAAK,GACb8J,EAAQ9J,KAAK,GACb8J,EAAQ9J,KAAK,GAEb5C,KAAK2M,aAAe3M,KAAKY,QAAQgM,kBAAkBF,EACvD,CAjEWrG,qBACP,OAAOrG,KAAK6L,eAChB,CAiEOrE,KAAKqF,GACR,MAAMxD,EAASrJ,KAAKsM,mBAAmBjD,OAEvC,IAAKA,EAAOH,UACR,OAAO,EAGXlJ,KAAKY,QAAQkM,gBAAgB9M,KAAK6L,iBAElC7L,KAAKY,QAAQ6I,aAAazJ,KAAKsM,mBAAmBlD,cAElD,MAAM2D,EAAkB/M,KAAKY,QAAQoM,mBA2BrC,OAzBAhN,KAAKY,QAAQqM,UAAS,GACtBjN,KAAKY,QAAQsM,gBAAe,GAC5BlN,KAAKY,QAAQyJ,eAAc,GAC3BrK,KAAKY,QAAQuM,iBAAiB,oBAC9BnN,KAAKY,QAAQwM,eAAc,GAE3BpN,KAAKY,QAAQ8I,YACT1J,KAAK0L,eACL1L,KAAK2M,aACLtD,GAGJA,EAAOgE,aAAa,eAAgBR,GAEpC7M,KAAKY,QAAQqJ,iBACT,sCACA,EACA,GAGJjK,KAAKY,QAAQuM,iBAAiBJ,GAC9B/M,KAAKY,QAAQwM,eAAc,GAE3BpN,KAAKY,QAAQ0M,kBAAkBtN,KAAK6L,kBAE7B,CACX,CAEOpI,U,MACHzD,KAAK6L,gBAAgBpI,UAEiC,QAAtD,EAAAzD,KAAK0L,eAAe,oCAAkC,SAAEjI,UACxDzD,KAAK0L,eAAiB,CAAC,EAEnB1L,KAAK2M,eACL3M,KAAKY,QAAQ2M,eAAevN,KAAK2M,cACjC3M,KAAK2M,aAAe,KAE5B,E","sources":["webpack://babylonjs-fluid-rendering/./src/scenes/FluidRenderer/fluidRenderer.ts","webpack://babylonjs-fluid-rendering/./src/assets/shaders/particleDepth.vertex.glsl","webpack://babylonjs-fluid-rendering/./src/assets/shaders/particleDepth.fragment.glsl","webpack://babylonjs-fluid-rendering/./src/assets/shaders/particleThickness.vertex.glsl","webpack://babylonjs-fluid-rendering/./src/assets/shaders/particleThickness.fragment.glsl","webpack://babylonjs-fluid-rendering/./src/assets/shaders/particleDiffuse.vertex.glsl","webpack://babylonjs-fluid-rendering/./src/assets/shaders/particleDiffuse.fragment.glsl","webpack://babylonjs-fluid-rendering/./src/assets/shaders/bilateralBlur.fragment.glsl","webpack://babylonjs-fluid-rendering/./src/assets/shaders/standardBlur.fragment.glsl","webpack://babylonjs-fluid-rendering/./src/assets/shaders/renderFluid.fragment.glsl","webpack://babylonjs-fluid-rendering/./src/assets/shaders/renderFluid.fragment.wgsl","webpack://babylonjs-fluid-rendering/./src/assets/shaders/passDepth.vertex.glsl","webpack://babylonjs-fluid-rendering/./src/assets/shaders/passDepth.fragment.glsl","webpack://babylonjs-fluid-rendering/./src/assets/shaders/passDepth.vertex.wgsl","webpack://babylonjs-fluid-rendering/./src/assets/shaders/passDepth.fragment.wgsl","webpack://babylonjs-fluid-rendering/./src/assets/shaders/postprocess.vertex.wgsl","webpack://babylonjs-fluid-rendering/./src/scenes/FluidRenderer/fluidRenderingObject.ts","webpack://babylonjs-fluid-rendering/./src/scenes/FluidRenderer/fluidRenderingObjectParticleSystem.ts","webpack://babylonjs-fluid-rendering/./src/scenes/FluidRenderer/fluidRenderingObjectVertexBuffer.ts","webpack://babylonjs-fluid-rendering/./src/scenes/Utils/copyDepthTexture.ts"],"sourcesContent":["import * as BABYLON from \"@babylonjs/core\";\n\nimport { Scene } from \"@babylonjs/core/scene\";\nimport { FluidRenderingObject } from \"./fluidRenderingObject\";\n\nimport particleDepthVertex from \"../../assets/shaders/particleDepth.vertex.glsl\";\nimport particleDepthFragment from \"../../assets/shaders/particleDepth.fragment.glsl\";\n\nimport particleThicknessVertex from \"../../assets/shaders/particleThickness.vertex.glsl\";\nimport particleThicknessFragment from \"../../assets/shaders/particleThickness.fragment.glsl\";\n\nimport particleDiffuseVertex from \"../../assets/shaders/particleDiffuse.vertex.glsl\";\nimport particleDiffuseFragment from \"../../assets/shaders/particleDiffuse.fragment.glsl\";\n\nimport bilateralBlurFragment from \"../../assets/shaders/bilateralBlur.fragment.glsl\";\nimport standardBlurFragment from \"../../assets/shaders/standardBlur.fragment.glsl\";\n\nimport renderFluidFragment from \"../../assets/shaders/renderFluid.fragment.glsl\";\nimport renderFluidWGSLFragment from \"../../assets/shaders/renderFluid.fragment.wgsl\";\n\nimport passDepthVertex from \"../../assets/shaders/passDepth.vertex.glsl\";\nimport passDepthFragment from \"../../assets/shaders/passDepth.fragment.glsl\";\n\nimport passDepthWGSLVertex from \"../../assets/shaders/passDepth.vertex.wgsl\";\nimport passDepthWGSLFragment from \"../../assets/shaders/passDepth.fragment.wgsl\";\n\nimport postprocessWGSLVertex from \"../../assets/shaders/postprocess.vertex.wgsl\";\n\nimport { FluidRenderingObjectParticleSystem } from \"./fluidRenderingObjectParticleSystem\";\nimport { FluidRenderingTargetRenderer } from \"./fluidRenderingTargetRenderer\";\nimport { FluidRenderingObjectVertexBuffer } from \"./fluidRenderingObjectVertexBuffer\";\nimport { CopyDepthTexture } from \"scenes/Utils/copyDepthTexture\";\n\ndeclare module \"@babylonjs/core/Particles/IParticleSystem\" {\n    export interface IParticleSystem {\n        renderAsFluid: boolean;\n    }\n}\n\ndeclare module \"@babylonjs/core/Particles/ParticleSystem\" {\n    export interface ParticleSystem {\n        /** @hidden (Backing field) */\n        _renderAsFluid: boolean;\n\n        renderAsFluid: boolean;\n    }\n}\n\nObject.defineProperty(BABYLON.ParticleSystem.prototype, \"renderAsFluid\", {\n    get: function (this: BABYLON.ParticleSystem) {\n        return this._renderAsFluid;\n    },\n    set: function (this: BABYLON.ParticleSystem, value: boolean) {\n        this._renderAsFluid = value;\n        this._scene?.fluidRenderer?.collectParticleSystems();\n    },\n    enumerable: true,\n    configurable: true,\n});\n\nexport interface IFluidRenderingRenderObject {\n    object: FluidRenderingObject;\n    targetRenderer: FluidRenderingTargetRenderer;\n}\n\nexport class FluidRenderer {\n    /** @hidden */\n    public static _SceneComponentInitialization: (scene: Scene) => void =\n        (/*_*/) => {\n            throw `FluidRendererSceneComponent needs to be imported before as it contains a side-effect required by your code.`;\n        };\n\n    private _scene: BABYLON.Scene;\n    private _engine: BABYLON.Engine;\n    private _onEngineResizeObserver: BABYLON.Nullable<\n        BABYLON.Observer<BABYLON.Engine>\n    >;\n    private _renderObjects: Array<IFluidRenderingRenderObject>;\n    private _targetRenderers: FluidRenderingTargetRenderer[];\n    private _cameras: Map<\n        BABYLON.Camera,\n        [\n            Array<FluidRenderingTargetRenderer>,\n            { [key: string]: CopyDepthTexture }\n        ]\n    >;\n\n    public get renderObjects() {\n        return this._renderObjects;\n    }\n\n    public get targetRenderers() {\n        return this._targetRenderers;\n    }\n\n    constructor(scene: BABYLON.Scene) {\n        this._scene = scene;\n        this._engine = scene.getEngine();\n        this._onEngineResizeObserver = null;\n        this._renderObjects = [];\n        this._targetRenderers = [];\n        this._cameras = new Map();\n\n        FluidRenderer._SceneComponentInitialization(this._scene);\n\n        this._onEngineResizeObserver = this._engine.onResizeObservable.add(\n            () => {\n                this._initialize();\n            }\n        );\n\n        this.collectParticleSystems();\n    }\n\n    public recreate(): void {\n        this._sortRenderingObjects();\n        this._initialize();\n    }\n\n    public getRenderObjectFromParticleSystem(\n        ps: BABYLON.ParticleSystem\n    ): BABYLON.Nullable<IFluidRenderingRenderObject> {\n        const index = this._getParticleSystemIndex(ps);\n        return index !== -1 ? this._renderObjects[index] : null;\n    }\n\n    public getRenderObjectFromVertexBuffer(\n        vb: BABYLON.VertexBuffer\n    ): BABYLON.Nullable<IFluidRenderingRenderObject> {\n        const index = this._getVertexBufferIndex(vb);\n        return index !== -1 ? this._renderObjects[index] : null;\n    }\n\n    public addParticleSystem(\n        ps: BABYLON.ParticleSystem,\n        generateDiffuseTexture?: boolean,\n        targetRenderer?: FluidRenderingTargetRenderer,\n        camera?: BABYLON.Camera\n    ): IFluidRenderingRenderObject {\n        const object = new FluidRenderingObjectParticleSystem(this._scene, ps);\n\n        object.onParticleSizeChanged.add(\n            this._setParticleSizeForRenderTargets.bind(this)\n        );\n\n        if (!targetRenderer) {\n            targetRenderer = new FluidRenderingTargetRenderer(\n                this._scene,\n                camera\n            );\n            this._targetRenderers.push(targetRenderer);\n        }\n\n        if (!targetRenderer.onUseVelocityChanged.hasObservers()) {\n            targetRenderer.onUseVelocityChanged.add(\n                this._setUseVelocityForRenderObject.bind(this)\n            );\n        }\n\n        if (generateDiffuseTexture !== undefined) {\n            targetRenderer.generateDiffuseTexture = generateDiffuseTexture;\n        }\n\n        const renderObject = { object, targetRenderer };\n\n        this._renderObjects.push(renderObject);\n\n        this._sortRenderingObjects();\n\n        this._setParticleSizeForRenderTargets();\n\n        return renderObject;\n    }\n\n    public addVertexBuffer(\n        vertexBuffers: { [key: string]: BABYLON.VertexBuffer },\n        numParticles: number,\n        generateDiffuseTexture?: boolean,\n        targetRenderer?: FluidRenderingTargetRenderer,\n        camera?: BABYLON.Camera\n    ): IFluidRenderingRenderObject {\n        const object = new FluidRenderingObjectVertexBuffer(\n            this._scene,\n            vertexBuffers,\n            numParticles\n        );\n\n        object.onParticleSizeChanged.add(\n            this._setParticleSizeForRenderTargets.bind(this)\n        );\n\n        if (!targetRenderer) {\n            targetRenderer = new FluidRenderingTargetRenderer(\n                this._scene,\n                camera\n            );\n            this._targetRenderers.push(targetRenderer);\n        }\n\n        if (!targetRenderer.onUseVelocityChanged.hasObservers()) {\n            targetRenderer.onUseVelocityChanged.add(\n                this._setUseVelocityForRenderObject.bind(this)\n            );\n        }\n\n        if (generateDiffuseTexture !== undefined) {\n            targetRenderer.generateDiffuseTexture = generateDiffuseTexture;\n        }\n\n        const renderObject = { object, targetRenderer };\n\n        this._renderObjects.push(renderObject);\n\n        this._sortRenderingObjects();\n\n        this._setParticleSizeForRenderTargets();\n\n        return renderObject;\n    }\n\n    public removeRenderObject(\n        renderObject: IFluidRenderingRenderObject,\n        removeUnusedTargetRenderer = true\n    ): boolean {\n        const index = this._renderObjects.indexOf(renderObject);\n        if (index === -1) {\n            return false;\n        }\n\n        renderObject.object.dispose();\n\n        this._renderObjects.splice(index, 1);\n\n        if (removeUnusedTargetRenderer && this._removeUnusedTargetRenderers()) {\n            this._initialize();\n        } else {\n            this._setParticleSizeForRenderTargets();\n        }\n\n        return true;\n    }\n\n    private _sortRenderingObjects(): void {\n        this._renderObjects.sort((a, b) => {\n            return a.object.priority < b.object.priority\n                ? -1\n                : a.object.priority > b.object.priority\n                ? 1\n                : 0;\n        });\n    }\n\n    public collectParticleSystems(): void {\n        for (let i = 0; i < this._scene.particleSystems.length; ++i) {\n            const ps = this._scene.particleSystems[i];\n            const index = this._getParticleSystemIndex(ps);\n            if (index === -1) {\n                if (\n                    ps.renderAsFluid &&\n                    ps.getClassName() === \"ParticleSystem\"\n                ) {\n                    this.addParticleSystem(ps as BABYLON.ParticleSystem, true);\n                }\n            } else if (!ps.renderAsFluid) {\n                this._renderObjects[index].object.dispose();\n                this._renderObjects.splice(index, 1);\n            }\n        }\n        this._removeUnusedTargetRenderers();\n        this._initialize();\n    }\n\n    private _removeUnusedTargetRenderers(): boolean {\n        const indexes: { [id: number]: boolean } = {};\n\n        for (let i = 0; i < this._renderObjects.length; ++i) {\n            const targetRenderer = this._renderObjects[i].targetRenderer;\n            indexes[this._targetRenderers.indexOf(targetRenderer)] = true;\n        }\n\n        let removed = false;\n        const newList: Array<FluidRenderingTargetRenderer> = [];\n        for (let i = 0; i < this._targetRenderers.length; ++i) {\n            if (!indexes[i]) {\n                this._targetRenderers[i].dispose();\n                removed = true;\n            } else {\n                newList.push(this._targetRenderers[i]);\n            }\n        }\n\n        if (removed) {\n            this._targetRenderers.length = 0;\n            this._targetRenderers.push(...newList);\n        }\n\n        return removed;\n    }\n\n    private static _IsParticleSystemObject(\n        obj: FluidRenderingObject\n    ): obj is FluidRenderingObjectParticleSystem {\n        return !!(obj as FluidRenderingObjectParticleSystem).particleSystem;\n    }\n\n    private static _IsVertexBufferObject(\n        obj: FluidRenderingObject\n    ): obj is FluidRenderingObjectVertexBuffer {\n        return (\n            (obj as FluidRenderingObjectVertexBuffer).getClassName() ===\n            \"FluidRenderingObjectVertexBuffer\"\n        );\n    }\n\n    private _getParticleSystemIndex(ps: BABYLON.IParticleSystem): number {\n        for (let i = 0; i < this._renderObjects.length; ++i) {\n            const obj = this._renderObjects[i].object;\n            if (\n                FluidRenderer._IsParticleSystemObject(obj) &&\n                obj.particleSystem === ps\n            ) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    private _getVertexBufferIndex(vb: BABYLON.VertexBuffer): number {\n        for (let i = 0; i < this._renderObjects.length; ++i) {\n            const obj = this._renderObjects[i].object;\n            if (\n                FluidRenderer._IsVertexBufferObject(obj) &&\n                obj.vertexBuffers[BABYLON.VertexBuffer.PositionKind] === vb\n            ) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n\n    private _initialize(): void {\n        for (let i = 0; i < this._targetRenderers.length; ++i) {\n            this._targetRenderers[i].dispose();\n        }\n\n        const cameras: Map<\n            BABYLON.Camera,\n            [\n                Array<FluidRenderingTargetRenderer>,\n                { [key: string]: CopyDepthTexture }\n            ]\n        > = new Map();\n\n        for (let i = 0; i < this._targetRenderers.length; ++i) {\n            const targetRenderer = this._targetRenderers[i];\n\n            targetRenderer.initialize();\n\n            if (targetRenderer.camera && targetRenderer.renderPostProcess) {\n                let list = cameras.get(targetRenderer.camera);\n                if (!list) {\n                    list = [[], {}];\n                    cameras.set(targetRenderer.camera, list);\n                }\n                list[0].push(targetRenderer);\n                targetRenderer.camera.attachPostProcess(\n                    targetRenderer.renderPostProcess,\n                    i\n                );\n            }\n        }\n\n        for (const [camera, list] of cameras) {\n            const firstPostProcess = camera._getFirstPostProcess();\n            if (!firstPostProcess) {\n                continue;\n            }\n\n            const [targetRenderers, copyDepthTextures] = list;\n\n            firstPostProcess.onSizeChangedObservable.add(() => {\n                if (!firstPostProcess.inputTexture.depthStencilTexture) {\n                    firstPostProcess.inputTexture.createDepthStencilTexture(\n                        0,\n                        true,\n                        this._engine.isStencilEnable,\n                        targetRenderers[0].samples\n                    );\n                }\n                for (const targetRenderer of targetRenderers) {\n                    const thicknessRT =\n                        targetRenderer.thicknessRenderTarget?.renderTarget;\n                    const thicknessTexture = thicknessRT?.texture;\n                    if (thicknessRT && thicknessTexture) {\n                        const key =\n                            thicknessTexture.width +\n                            \"_\" +\n                            thicknessTexture.height;\n                        let copyDepthTexture = copyDepthTextures[key];\n                        if (!copyDepthTexture) {\n                            copyDepthTexture = copyDepthTextures[key] =\n                                new CopyDepthTexture(\n                                    this._engine,\n                                    thicknessTexture.width,\n                                    thicknessTexture.height\n                                );\n                        }\n                        copyDepthTexture.depthRTWrapper._shareDepth(\n                            thicknessRT\n                        );\n                    }\n                }\n            });\n        }\n\n        // Dispose the CopyDepthTexture instances that we don't need anymore\n        for (const [camera, list] of this._cameras) {\n            const copyDepthTextures = list[1];\n\n            const list2 = cameras.get(camera);\n            if (!list2) {\n                for (const key in copyDepthTextures) {\n                    copyDepthTextures[key].dispose();\n                }\n            } else {\n                for (const key in copyDepthTextures) {\n                    if (!list2[1][key]) {\n                        copyDepthTextures[key].dispose();\n                    }\n                }\n            }\n        }\n\n        this._cameras.clear();\n        this._cameras = cameras;\n\n        this._setParticleSizeForRenderTargets();\n    }\n\n    private _setParticleSizeForRenderTargets(): void {\n        const particleSizes = new Map<FluidRenderingTargetRenderer, number>();\n\n        for (let i = 0; i < this._renderObjects.length; ++i) {\n            const renderingObject = this._renderObjects[i];\n            let curSize = particleSizes.get(renderingObject.targetRenderer);\n            if (curSize === undefined) {\n                curSize = 0;\n            }\n            particleSizes.set(\n                renderingObject.targetRenderer,\n                Math.max(curSize, renderingObject.object.particleSize)\n            );\n        }\n\n        for (const [targetRenderer, particleSize] of particleSizes) {\n            if (targetRenderer.depthRenderTarget) {\n                targetRenderer.depthRenderTarget.particleSize = particleSize;\n            }\n        }\n    }\n\n    private _setUseVelocityForRenderObject(): void {\n        for (let i = 0; i < this._renderObjects.length; ++i) {\n            const renderingObject = this._renderObjects[i];\n            renderingObject.object.useVelocity =\n                renderingObject.targetRenderer.useVelocity;\n        }\n    }\n\n    /** @hidden */\n    public _prepareRendering(): void {\n        let needInitialization = false;\n        for (let i = 0; i < this._targetRenderers.length; ++i) {\n            needInitialization =\n                needInitialization ||\n                this._targetRenderers[i].needInitialization;\n        }\n        if (needInitialization) {\n            this._initialize();\n        }\n    }\n\n    /** @hidden */\n    public _render(forCamera?: BABYLON.Camera): void {\n        for (let i = 0; i < this._targetRenderers.length; ++i) {\n            if (!forCamera || this._targetRenderers[i].camera === forCamera) {\n                this._targetRenderers[i].clearTargets();\n            }\n        }\n\n        for (const [camera, list] of this._cameras) {\n            if (forCamera && camera !== forCamera) {\n                continue;\n            }\n\n            const firstPostProcess = camera._getFirstPostProcess();\n            if (!firstPostProcess) {\n                continue;\n            }\n\n            const sourceCopyDepth =\n                firstPostProcess.inputTexture?.depthStencilTexture;\n            if (sourceCopyDepth) {\n                const [targetRenderers, copyDepthTextures] = list;\n                for (const targetRenderer of targetRenderers) {\n                    targetRenderer._bgDepthTexture = sourceCopyDepth;\n                }\n                for (const key in copyDepthTextures) {\n                    copyDepthTextures[key].copy(sourceCopyDepth);\n                }\n            }\n        }\n\n        for (let i = 0; i < this._renderObjects.length; ++i) {\n            const renderingObject = this._renderObjects[i];\n            if (\n                !forCamera ||\n                renderingObject.targetRenderer.camera === forCamera\n            ) {\n                renderingObject.targetRenderer.render(renderingObject.object);\n            }\n        }\n    }\n\n    public dispose(): void {\n        this._engine.onResizeObservable.remove(this._onEngineResizeObserver);\n        this._onEngineResizeObserver = null;\n\n        for (let i = 0; i < this._renderObjects.length; ++i) {\n            this._renderObjects[i].object.dispose();\n        }\n\n        for (let i = 0; i < this._targetRenderers.length; ++i) {\n            this._targetRenderers[i].dispose();\n        }\n\n        for (const key of this._cameras) {\n            const copyDepthTextures = key[1][1];\n            for (const key in copyDepthTextures) {\n                copyDepthTextures[key].dispose();\n            }\n        }\n\n        this._renderObjects = [];\n        this._targetRenderers = [];\n        this._cameras.clear();\n    }\n}\n\nBABYLON.ShaderStore.ShadersStore[\"fluidParticleDepthVertexShader\"] =\n    particleDepthVertex;\nBABYLON.ShaderStore.ShadersStore[\"fluidParticleDepthFragmentShader\"] =\n    particleDepthFragment;\n\nBABYLON.ShaderStore.ShadersStore[\"fluidParticleThicknessVertexShader\"] =\n    particleThicknessVertex;\nBABYLON.ShaderStore.ShadersStore[\"fluidParticleThicknessFragmentShader\"] =\n    particleThicknessFragment;\n\nBABYLON.ShaderStore.ShadersStore[\"fluidParticleDiffuseVertexShader\"] =\n    particleDiffuseVertex;\nBABYLON.ShaderStore.ShadersStore[\"fluidParticleDiffuseFragmentShader\"] =\n    particleDiffuseFragment;\n\nBABYLON.ShaderStore.ShadersStore[\"bilateralBlurFragmentShader\"] =\n    bilateralBlurFragment;\n\nBABYLON.ShaderStore.ShadersStore[\"standardBlurFragmentShader\"] =\n    standardBlurFragment;\n\nBABYLON.ShaderStore.ShadersStore[\"renderFluidFragmentShader\"] =\n    renderFluidFragment;\nBABYLON.ShaderStore.ShadersStoreWGSL[\"renderFluidFragmentShader\"] =\n    renderFluidWGSLFragment;\n\nBABYLON.ShaderStore.ShadersStore[\"passDepthVertexShader\"] = passDepthVertex;\nBABYLON.ShaderStore.ShadersStore[\"passDepthFragmentShader\"] = passDepthFragment;\n\nBABYLON.ShaderStore.ShadersStoreWGSL[\"passDepthVertexShader\"] =\n    passDepthWGSLVertex;\nBABYLON.ShaderStore.ShadersStoreWGSL[\"passDepthFragmentShader\"] =\n    passDepthWGSLFragment;\n\nBABYLON.ShaderStore.ShadersStoreWGSL[\"postprocessVertexShader\"] =\n    postprocessWGSLVertex;\n","export default \"attribute vec3 position;\\nattribute vec2 offset;\\n\\nuniform mat4 view;\\nuniform mat4 projection;\\nuniform vec2 size;\\n\\nvarying vec2 uv;\\nvarying vec3 viewPos;\\nvarying float sphereRadius;\\n\\n#ifdef FLUIDRENDERING_VELOCITY\\n    attribute vec3 velocity;\\n    varying float velocityNorm;\\n#endif\\n\\nvoid main(void) {\\n    vec3 cornerPos;\\n    cornerPos.xy = vec2(offset.x - 0.5, offset.y - 0.5) * size;\\n    cornerPos.z = 0.0;\\n\\n    viewPos = (view * vec4(position, 1.0)).xyz;\\n\\n    gl_Position = projection * vec4(viewPos + cornerPos, 1.0);\\n\\n    uv = offset;\\n    sphereRadius = size.x / 2.0;\\n#ifdef FLUIDRENDERING_VELOCITY\\n    velocityNorm = length(velocity);\\n#endif\\n}\\n\";","export default \"uniform mat4 projection;\\n\\nvarying vec2 uv;\\nvarying vec3 viewPos;\\nvarying float sphereRadius;\\n\\n#ifdef FLUIDRENDERING_VELOCITY\\n    varying float velocityNorm;\\n#endif\\n\\nvoid main(void) {\\n    vec3 normal;\\n\\n    normal.xy = uv * 2.0 - 1.0;\\n    float r2 = dot(normal.xy, normal.xy);\\n    if (r2 > 1.0) discard;\\n    normal.z = -sqrt(1.0 - r2);\\n\\n    vec4 realViewPos = vec4(viewPos + normal * sphereRadius, 1.0);\\n    vec4 clipSpacePos = projection * realViewPos;\\n\\n#ifdef WEBGPU\\n    gl_FragDepth = clipSpacePos.z / clipSpacePos.w;\\n#else\\n    gl_FragDepth = (clipSpacePos.z / clipSpacePos.w) * 0.5 + 0.5;\\n#endif\\n\\n#ifdef FLUIDRENDERING_VELOCITY\\n    glFragColor = vec4(realViewPos.z, velocityNorm, 0., 1.);\\n#else\\n    glFragColor = vec4(realViewPos.z, 0., 0., 1.);\\n#endif\\n}\\n\";","export default \"attribute vec3 position;\\nattribute vec2 offset;\\n\\nuniform mat4 view;\\nuniform mat4 projection;\\nuniform vec2 size;\\n\\nvarying vec2 uv;\\n\\nvoid main(void) {\\n    vec3 cornerPos;\\n    cornerPos.xy = vec2(offset.x - 0.5, offset.y - 0.5) * size;\\n    cornerPos.z = 0.0;\\n\\n    vec3 viewPos = (view * vec4(position, 1.0)).xyz + cornerPos;\\n\\n    gl_Position = projection * vec4(viewPos, 1.0);\\n\\n    uv = offset;\\n}\\n\";","export default \"uniform float particleAlpha;\\n\\nvarying vec2 uv;\\n\\nvoid main(void) {\\n    vec3 normal;\\n\\n    normal.xy = uv * 2.0 - 1.0;\\n    float r2 = dot(normal.xy, normal.xy);\\n    if (r2 > 1.0) discard;\\n    float thickness = sqrt(1.0 - r2);\\n\\n    glFragColor = vec4(vec3(particleAlpha * thickness), 1.0);\\n}\\n\";","export default \"attribute vec3 position;\\nattribute vec2 offset;\\nattribute vec4 color;\\n\\nuniform mat4 view;\\nuniform mat4 projection;\\nuniform vec2 size;\\n\\nvarying vec2 uv;\\nvarying vec3 diffuseColor;\\n\\nvoid main(void) {\\n    vec3 cornerPos;\\n    cornerPos.xy = vec2(offset.x - 0.5, offset.y - 0.5) * size;\\n    cornerPos.z = 0.0;\\n\\n    vec3 viewPos = (view * vec4(position, 1.0)).xyz + cornerPos;\\n\\n    gl_Position = projection * vec4(viewPos, 1.0);\\n\\n    uv = offset;\\n    diffuseColor = color.rgb;\\n}\\n\";","export default \"uniform float particleAlpha;\\n\\nvarying vec2 uv;\\nvarying vec3 diffuseColor;\\n\\nvoid main(void) {\\n    vec3 normal;\\n\\n    normal.xy = uv * 2.0 - 1.0;\\n    float r2 = dot(normal.xy, normal.xy);\\n    if (r2 > 1.0) discard;\\n\\n    glFragColor = vec4(diffuseColor, 1.0);\\n}\\n\";","export default \"uniform sampler2D textureSampler;\\n\\nuniform int maxFilterSize;\\nuniform vec2 blurDir;\\nuniform float projectedParticleConstant;\\nuniform float depthThreshold;\\n\\nvarying vec2 vUV;\\n\\nvoid main(void) {\\n    float depth = texture2D(textureSampler, vUV).x;\\n\\n    if (depth >= 1e6 || depth <= 0.) {\\n        glFragColor = vec4(vec3(depth), 1.);\\n        return;\\n    }\\n\\n    int filterSize = min(maxFilterSize, int(ceil(projectedParticleConstant / depth)));\\n    float sigma = float(filterSize) / 3.0;\\n    float two_sigma2 = 2.0 * sigma * sigma;\\n\\n    float sigmaDepth = depthThreshold / 3.0;\\n    float two_sigmaDepth2 = 2.0 * sigmaDepth * sigmaDepth;\\n\\n    float sum = 0.;\\n    float wsum = 0.;\\n    float sumVel = 0.;\\n\\n    for (int x = -filterSize; x <= filterSize; ++x) {\\n        vec2 coords = vec2(x);\\n        vec2 sampleDepthVel = texture2D(textureSampler, vUV + coords * blurDir).rg;\\n\\n        float r = dot(coords, coords);\\n        float w = exp(-r / two_sigma2);\\n\\n        float rDepth = sampleDepthVel.r - depth;\\n        float wd = exp(-rDepth * rDepth / two_sigmaDepth2);\\n\\n        sum += sampleDepthVel.r * w * wd;\\n        sumVel += sampleDepthVel.g * w * wd;\\n        wsum += w * wd;\\n    }\\n\\n    glFragColor = vec4(sum / wsum, sumVel / wsum, 0., 1.);\\n}\\n\";","export default \"uniform sampler2D textureSampler;\\n\\nuniform int filterSize;\\nuniform vec2 blurDir;\\n\\nvarying vec2 vUV;\\n\\nvoid main(void) {\\n    vec4 s = texture2D(textureSampler, vUV);\\n    if (s.r == 0.) {\\n        glFragColor = vec4(0., 0., 0., 1.);\\n        return;\\n    }\\n\\n    float sigma = float(filterSize) / 3.0;\\n    float twoSigma2 = 2.0 * sigma * sigma;\\n\\n    vec4 sum = vec4(0.);\\n    float wsum = 0.;\\n\\n    for (int x = -filterSize; x <= filterSize; ++x) {\\n        vec2 coords = vec2(x);\\n        vec4 sampl = texture2D(textureSampler, vUV + coords * blurDir);\\n\\n        float w = exp(-coords.x * coords.x / twoSigma2);\\n\\n        sum += sampl * w;\\n        wsum += w;\\n    }\\n\\n    sum /= wsum;\\n\\n    glFragColor = vec4(sum.rgb, 1.);\\n}\\n\";","export default \"// Index of refraction for water\\n#define IOR 1.333\\n\\n// Ratios of air and water IOR for refraction\\n// Air to water\\n#define ETA 1.0/IOR\\n\\n// Fresnel at 0°\\n#define F0 0.02\\n\\nuniform sampler2D textureSampler;\\nuniform sampler2D depthSampler;\\n#ifdef FLUIDRENDERING_DIFFUSETEXTURE\\n    uniform sampler2D diffuseSampler;\\n#else\\n    uniform vec3 diffuseColor;\\n#endif\\n#ifdef FLUIDRENDERING_FIXED_THICKNESS\\n    uniform float thickness;\\n    uniform sampler2D bgDepthSampler;\\n#else\\n    uniform float minimumThickness;\\n    uniform sampler2D thicknessSampler;\\n#endif\\nuniform samplerCube reflectionSampler;\\n#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_TEXTURE)\\n    uniform sampler2D debugSampler;\\n#endif\\n\\nuniform mat4 viewMatrix;\\nuniform mat4 projectionMatrix;\\nuniform mat4 invProjectionMatrix;\\nuniform vec2 texelSize;\\nuniform vec3 dirLight;\\nuniform float cameraFar;\\nuniform float density;\\nuniform float refractionStrength;\\nuniform float fresnelClamp;\\nuniform float specularPower;\\nuniform vec3 surfaceColor;\\n\\nvarying vec2 vUV;\\n\\nvec3 computeViewPosFromUVDepth(vec2 texCoord, float depth) {\\n    vec4 ndc;\\n    \\n    ndc.xy = texCoord * 2.0 - 1.0;\\n    ndc.z = projectionMatrix[2].z + projectionMatrix[3].z / depth;\\n    ndc.w = 1.0;\\n\\n    vec4 eyePos = invProjectionMatrix * ndc;\\n    eyePos.xyz /= eyePos.w;\\n\\n    return eyePos.xyz;\\n}\\n\\nvec3 getViewPosFromTexCoord(vec2 texCoord) {\\n    float depth = texture2D(depthSampler, texCoord).x;\\n    return computeViewPosFromUVDepth(texCoord, depth);\\n}\\n\\nvoid main(void) {\\n    vec2 texCoord = vUV;\\n\\n#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_TEXTURE)\\n    vec4 color = texture2D(debugSampler, texCoord);\\n    #ifdef FLUIDRENDERING_DEBUG_DEPTH\\n        glFragColor = vec4(color.rgb / vec3(2.0), 1.);\\n        if (color.r > 0.999 && color.g > 0.999) {\\n            glFragColor = texture2D(textureSampler, texCoord);\\n        }\\n    #else\\n        glFragColor = vec4(color.rgb, 1.);\\n        if (color.r < 0.001 && color.g < 0.001 && color.b < 0.001) {\\n            glFragColor = texture2D(textureSampler, texCoord);\\n        }\\n    #endif\\n    return;\\n#endif\\n\\n    vec2 depthVel = texture2D(depthSampler, texCoord).rg;\\n    float depth = depthVel.r;\\n#ifndef FLUIDRENDERING_FIXED_THICKNESS\\n    float thickness = texture2D(thicknessSampler, texCoord).x;\\n#else\\n    float bgDepth = texture2D(bgDepthSampler, texCoord).x;\\n    float depthNonLinear = projectionMatrix[2].z + projectionMatrix[3].z / depth;\\n    depthNonLinear = depthNonLinear * 0.5 + 0.5;\\n#endif\\n\\n#ifndef FLUIDRENDERING_FIXED_THICKNESS\\n    if (depth >= cameraFar || depth <= 0. || thickness <= minimumThickness) {\\n#else\\n    if (depth >= cameraFar || depth <= 0. || bgDepth <= depthNonLinear) {\\n#endif\\n//        vec3 backColor = texture2D(textureSampler, texCoord).rgb;\\n        glFragColor = texture2D(textureSampler, texCoord);\\n        return;\\n    }\\n\\n    // calculate view-space position from depth\\n    vec3 viewPos = computeViewPosFromUVDepth(texCoord, depth);\\n\\n    // calculate normal\\n    vec3 ddx = getViewPosFromTexCoord(texCoord + vec2(texelSize.x, 0.)) - viewPos;\\n    vec3 ddy = getViewPosFromTexCoord(texCoord + vec2(0., texelSize.y)) - viewPos;\\n\\n    vec3 ddx2 = viewPos - getViewPosFromTexCoord(texCoord + vec2(-texelSize.x, 0.));\\n    if (abs(ddx.z) > abs(ddx2.z)) {\\n        ddx = ddx2;\\n    }\\n\\n    vec3 ddy2 = viewPos - getViewPosFromTexCoord(texCoord + vec2(0., -texelSize.y));\\n    if (abs(ddy.z) > abs(ddy2.z)) {\\n        ddy = ddy2;\\n    }\\n\\n    vec3 normal = normalize(cross(ddy, ddx));\\n    if(isnan(normal.x) || isnan(normal.y) || isnan(normal.z) ||\\n    isinf(normal.x) || isinf(normal.y) || isinf(normal.z)) {\\n        normal = vec3(0., 0., -1.);\\n    }\\n\\n#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_SHOWNORMAL)\\n    glFragColor = vec4(normal * 0.5 + 0.5, 1.0);\\n    return;\\n#endif\\n\\n    // shading\\n    vec3 rayDir = normalize(viewPos); // direction from camera position to view position\\n\\n#ifdef FLUIDRENDERING_DIFFUSETEXTURE\\n    vec3 diffuseColor = texture2D(diffuseSampler, texCoord).rgb;\\n#endif\\n\\n    vec3  lightDir = normalize(vec3(viewMatrix * vec4(-dirLight, 0.)));\\n    vec3  H        = normalize(lightDir - rayDir);\\n    float specular = pow(max(0.0, dot(H, normal)), specularPower);\\n\\n#ifdef FLUIDRENDERING_DEBUG_DIFFUSERENDERING\\n    float diffuse  = max(0.0, dot(lightDir, normal)) * 1.0;\\n\\n    glFragColor = vec4(vec3(0.1) /*ambient*/ + vec3(0.42, 0.50, 1.00) * diffuse + vec3(0, 0, 0.2) + specular, 0.0);\\n    return;\\n#endif\\n\\n    // Refraction color\\n    vec3 refractionDir = refract(rayDir, normal, ETA);\\n\\n    vec3 transmitted = (texture2D(textureSampler, vec2(texCoord + refractionDir.xy * thickness * refractionStrength)).rgb);\\n    vec3 transmittance = exp(-density * thickness * (1.0 - diffuseColor)); // Beer law\\n   \\n    vec3 refractionColor = transmitted * transmittance;\\n\\n    // Reflection of the environment.\\n    vec3 reflectionDir = reflect(rayDir, normal);\\n    vec3 reflectionColor = (textureCube(reflectionSampler, reflectionDir).rgb);\\n\\n    // Combine refraction and reflection    \\n    float fresnel = clamp(F0 + (1.0 - F0) * pow(1.0 - dot(normal, -rayDir), 5.0), 0., fresnelClamp);\\n    \\n    vec3 finalColor = mix(refractionColor, reflectionColor, fresnel) + specular;\\n\\n#ifdef FLUIDRENDERING_VELOCITY\\n    float velocity = depthVel.g;\\n    finalColor = mix(finalColor, vec3(1.0), smoothstep(0.3, 1.0, velocity / 6.0));\\n#endif\\n    \\n    glFragColor = vec4(mix(finalColor, surfaceColor, dot(lightDir, normal) > 0.1 ? dot(lightDir, normal) : 0.0), 1.);\\n//    glFragColor = vec4(finalColor, 1.);\\n}\\n\";","export default \"// Index of refraction for water\\nlet IOR = 1.333;\\n\\n// Ratios of air and water IOR for refraction\\n// Air to water\\nlet ETA = 0.7501875468867217; // 1.0 / IOR;\\n\\n// Fresnel at 0°\\nlet F0 = 0.02;\\n\\nvar textureSampler : texture_2d<f32>;\\nvar textureSamplerSampler : sampler;\\nvar depthSampler : texture_2d<f32>;\\n#ifdef FLUIDRENDERING_DIFFUSETEXTURE\\n    var diffuseSampler : texture_2d<f32>;\\n    var diffuseSamplerSampler : sampler;\\n#else\\n    uniform diffuseColor : vec3<f32>;\\n#endif\\n#ifdef FLUIDRENDERING_FIXED_THICKNESS\\n    uniform thickness : f32;\\n    var bgDepthSampler: texture_depth_2d;\\n    var bgDepthSamplerSampler: sampler;\\n#else\\n    uniform minimumThickness : f32;\\n    var thicknessSampler : texture_2d<f32>;\\n    var thicknessSamplerSampler : sampler;\\n#endif\\nvar reflectionSampler : texture_cube<f32>;\\nvar reflectionSamplerSampler : sampler;\\n#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_TEXTURE)\\n    var debugSampler : texture_2d<f32>;\\n    var debugSamplerSampler : sampler;\\n#endif\\n\\nuniform viewMatrix : mat4x4<f32>;\\nuniform projectionMatrix : mat4x4<f32>;\\nuniform invProjectionMatrix : mat4x4<f32>;\\nuniform texelSize : vec2<f32>;\\nuniform dirLight : vec3<f32>;\\nuniform cameraFar : f32;\\nuniform density : f32;\\nuniform refractionStrength : f32;\\nuniform fresnelClamp : f32;\\nuniform specularPower : f32;\\n\\nvarying vUV : vec2<f32>;\\n\\nfn computeViewPosFromUVDepth(texCoord : vec2<f32>, depth : f32) -> vec3<f32> {\\n    let ndc = vec4(texCoord * 2.0 - 1.0, uniforms.projectionMatrix[2].z + uniforms.projectionMatrix[3].z / depth, 1.0);\\n\\n    var eyePos = uniforms.invProjectionMatrix * ndc;\\n\\n    return eyePos.xyz / eyePos.w;\\n}\\n\\nfn getViewPosFromTexCoord(texCoord : vec2<f32>) -> vec3<f32> {\\n    let dim = textureDimensions(depthSampler);\\n    let depth = textureLoad(depthSampler, vec2<i32>(texCoord * vec2<f32>(dim)), 0).x;\\n    return computeViewPosFromUVDepth(texCoord, depth);\\n}\\n\\n@stage(fragment)\\nfn main(input: FragmentInputs) -> FragmentOutputs {\\n    let texCoord = vUV;\\n\\n#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_TEXTURE)\\n    #ifdef FLUIDRENDERING_DEBUG_DEPTH\\n        let dim2 = textureDimensions(debugSampler);\\n        let color = textureLoad(debugSampler, vec2<i32>(texCoord * vec2<f32>(dim2)), 0);\\n        gl_FragColor = vec4(color.rgb / 2.0, 1.);\\n        if (color.r > 0.999 && color.g > 0.999) {\\n            gl_FragColor = textureSample(textureSampler, textureSamplerSampler, texCoord);\\n        }\\n    #else\\n        let color = textureSample(debugSampler, debugSamplerSampler, texCoord);\\n        gl_FragColor = vec4(color.rgb, 1.);\\n        if (color.r < 0.001 && color.g < 0.001 && color.b < 0.001) {\\n            gl_FragColor = textureSample(textureSampler, textureSamplerSampler, texCoord);\\n        }\\n    #endif\\n    output.color = gl_FragColor;\\n    return output;\\n#endif\\n\\n    let dim = textureDimensions(depthSampler);\\n    let depthVel = textureLoad(depthSampler, vec2<i32>(texCoord * vec2<f32>(dim)), 0).rg;\\n    let depth = depthVel.r;\\n#ifndef FLUIDRENDERING_FIXED_THICKNESS\\n    let thickness_ = textureSample(thicknessSampler, thicknessSamplerSampler, texCoord).x;\\n#else\\n    let bgDepth = textureSample(bgDepthSampler, bgDepthSamplerSampler, texCoord);\\n    let depthNonLinear = uniforms.projectionMatrix[2].z + uniforms.projectionMatrix[3].z / depth;\\n    let thickness_ = uniforms.thickness;\\n#endif\\n    let thickness = thickness_;\\n\\n#ifndef FLUIDRENDERING_FIXED_THICKNESS\\n    if (depth >= uniforms.cameraFar || depth <= 0. || thickness <= uniforms.minimumThickness) {\\n#else\\n    if (depth >= uniforms.cameraFar || depth <= 0. || bgDepth <= depthNonLinear) {\\n#endif\\n        let backColor = textureSample(textureSampler, textureSamplerSampler, texCoord).rgb;\\n        gl_FragColor = vec4(backColor, 1.);\\n        output.color = gl_FragColor;\\n        return output;\\n    }\\n\\n    // calculate view-space position from depth\\n    let viewPos = computeViewPosFromUVDepth(texCoord, depth);\\n\\n    // calculate normal\\n    var ddx = getViewPosFromTexCoord(texCoord + vec2(uniforms.texelSize.x, 0.)) - viewPos;\\n    var ddy = getViewPosFromTexCoord(texCoord + vec2(0., uniforms.texelSize.y)) - viewPos;\\n\\n    let ddx2 = viewPos - getViewPosFromTexCoord(texCoord + vec2(-uniforms.texelSize.x, 0.));\\n    if (abs(ddx.z) > abs(ddx2.z)) {\\n        ddx = ddx2;\\n    }\\n\\n    let ddy2 = viewPos - getViewPosFromTexCoord(texCoord + vec2(0., -uniforms.texelSize.y));\\n    if (abs(ddy.z) > abs(ddy2.z)) {\\n        ddy = ddy2;\\n    }\\n\\n    let normal = normalize(cross(ddy, ddx));\\n\\n#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_SHOWNORMAL)\\n    gl_FragColor = vec4(normal * 0.5 + 0.5, 1.0);\\n    output.color = gl_FragColor;\\n    return output;\\n#endif\\n\\n    // shading\\n    let rayDir = normalize(viewPos); // direction from camera position to view position\\n\\n#ifdef FLUIDRENDERING_DIFFUSETEXTURE\\n    let diffuseColor_ = textureSample(diffuseSampler, diffuseSamplerSampler, texCoord).rgb;\\n#else\\n    let diffuseColor_ = uniforms.diffuseColor;\\n#endif\\n    let diffuseColor = diffuseColor_;\\n\\n    let  lightDir = normalize((uniforms.viewMatrix * vec4(-uniforms.dirLight, 0.)).xyz);\\n    let  H        = normalize(lightDir - rayDir);\\n    let specular = pow(max(0.0, dot(H, normal)), uniforms.specularPower);\\n\\n#ifdef FLUIDRENDERING_DEBUG_DIFFUSERENDERING\\n    let diffuse  = max(0.0, dot(lightDir, normal)) * 1.0;\\n\\n    gl_FragColor = vec4(vec3(0.1) + vec3(0.42, 0.50, 1.00) * diffuse + vec3(0, 0, 0.2) + specular, 1.);\\n    output.color = gl_FragColor;\\n    return output;\\n#endif\\n\\n    // Refraction color\\n    let refractionDir = refract(rayDir, normal, ETA);\\n\\n    let transmitted = (textureSample(textureSampler, textureSamplerSampler, vec2(texCoord + refractionDir.xy * thickness * uniforms.refractionStrength)).rgb);\\n    let transmittance = exp(-uniforms.density * thickness * (1.0 - diffuseColor)); // Beer law\\n   \\n    let refractionColor = transmitted * transmittance;\\n\\n    // Reflection of the environment.\\n    let reflectionDir = reflect(rayDir, normal);\\n    let reflectionColor = textureSample(reflectionSampler, reflectionSamplerSampler, reflectionDir).rgb;\\n\\n    // Combine refraction and reflection    \\n    let fresnel = clamp(F0 + (1.0 - F0) * pow(1.0 - dot(normal, -rayDir), 5.0), 0., uniforms.fresnelClamp);\\n    \\n    var finalColor = mix(refractionColor, reflectionColor, fresnel) + specular;\\n\\n#ifdef FLUIDRENDERING_VELOCITY\\n    let velocity = depthVel.g;\\n    finalColor = mix(finalColor, vec3(1.0), smoothstep(0.3, 1.0, velocity / 6.0));\\n#endif\\n\\n    gl_FragColor = vec4(finalColor, 1.);\\n}\\n\";","export default \"attribute vec2 position;\\n\\nvarying vec2 vUV;\\n\\nconst vec2 madd = vec2(0.5, 0.5);\\n\\nvoid main(void) {\\n\\tvUV = position * madd + madd;\\n\\tgl_Position = vec4(position, 0.0, 1.0);\\n}\\n\";","export default \"uniform sampler2D textureDepth;\\n\\nvarying vec2 vUV;\\n\\nvoid main(void) \\n{\\n\\tgl_FragDepth = texture2D(textureDepth, vUV).x;\\n}\\n\";","export default \"attribute position: vec2<f32>;\\n\\nvarying vUV: vec2<f32>;\\n\\nlet madd = vec2(0.5, 0.5);\\n\\n@stage(vertex)\\nfn main(input : VertexInputs) -> FragmentInputs\\n{\\n\\tvUV = position * madd + madd;\\n\\tgl_Position = vec4(position, 0.0, 1.0);\\n}\\n\";","export default \"var textureDepth: texture_depth_2d;\\nvar textureDepthSampler: sampler;\\n\\nvarying vUV: vec2<f32>;\\n\\n@stage(fragment)\\nfn main(input: FragmentInputs) -> FragmentOutputs\\n{\\n\\tgl_FragDepth = textureSample(textureDepth, textureDepthSampler, vUV);\\n}\\n\";","export default \"// Attributes\\nattribute position : vec2<f32>;\\n\\nuniform scale : vec2<f32>;\\n// Output\\nvarying vUV : vec2<f32>;\\n\\nlet madd = vec2(0.5, 0.5);\\n\\n#define CUSTOM_VERTEX_DEFINITIONS\\n\\n@stage(vertex)\\nfn main(input : VertexInputs) -> FragmentInputs\\n{\\n#define CUSTOM_VERTEX_MAIN_BEGIN\\n\\n\\tvUV = (position * madd + madd) * uniforms.scale;\\n\\tgl_Position = vec4(position, 0.0, 1.0);\\n\\n#define CUSTOM_VERTEX_MAIN_END\\n}\\n\";","import * as BABYLON from \"@babylonjs/core\";\n\nexport abstract class FluidRenderingObject {\n    protected _scene: BABYLON.Scene;\n    protected _engine: BABYLON.Engine;\n    protected _effectsAreDirty: boolean;\n    protected _depthEffectWrapper: BABYLON.Nullable<BABYLON.EffectWrapper>;\n    protected _thicknessEffectWrapper: BABYLON.Nullable<BABYLON.EffectWrapper>;\n\n    public priority = 0;\n\n    protected _particleSize = 0.1;\n\n    public onParticleSizeChanged =\n        new BABYLON.Observable<FluidRenderingObject>();\n\n    public get particleSize() {\n        return this._particleSize;\n    }\n\n    public set particleSize(size: number) {\n        if (size === this._particleSize) {\n            return;\n        }\n\n        this._particleSize = size;\n        this.onParticleSizeChanged.notifyObservers(this);\n    }\n\n    public particleThicknessAlpha = 0.05;\n\n    public get useInstancing() {\n        return !this.indexBuffer;\n    }\n\n    private _useVelocity = true;\n\n    public get useVelocity() {\n        return this._useVelocity;\n    }\n\n    public set useVelocity(use: boolean) {\n        if (this._useVelocity === use || !this._hasVelocity()) {\n            return;\n        }\n\n        this._useVelocity = use;\n        this._effectsAreDirty = true;\n    }\n\n    private _hasVelocity() {\n        return !!this.vertexBuffers.velocity;\n    }\n\n    public getClassName(): string {\n        return \"FluidRenderingObject\";\n    }\n\n    constructor(\n        scene: BABYLON.Scene,\n        public readonly vertexBuffers: { [key: string]: BABYLON.VertexBuffer },\n        public readonly indexBuffer: BABYLON.Nullable<BABYLON.DataBuffer>\n    ) {\n        this._scene = scene;\n        this._engine = scene.getEngine();\n        this._effectsAreDirty = true;\n        this._depthEffectWrapper = null;\n        this._thicknessEffectWrapper = null;\n    }\n\n    protected _createEffects(): void {\n        const uniformNames = [\"view\", \"projection\", \"particleRadius\", \"size\"];\n        const attributeNames = [\"position\", \"offset\"];\n        const defines: string[] = [];\n\n        this._effectsAreDirty = false;\n\n        if (this.useVelocity) {\n            attributeNames.push(\"velocity\");\n            defines.push(\"#define FLUIDRENDERING_VELOCITY\");\n        }\n\n        this._depthEffectWrapper = new BABYLON.EffectWrapper({\n            engine: this._engine,\n            useShaderStore: true,\n            vertexShader: \"fluidParticleDepth\",\n            fragmentShader: \"fluidParticleDepth\",\n            attributeNames,\n            uniformNames,\n            samplerNames: [],\n            defines,\n        });\n\n        uniformNames.push(\"particleAlpha\");\n\n        this._thicknessEffectWrapper = new BABYLON.EffectWrapper({\n            engine: this._engine,\n            useShaderStore: true,\n            vertexShader: \"fluidParticleThickness\",\n            fragmentShader: \"fluidParticleThickness\",\n            attributeNames: [\"position\", \"offset\"],\n            uniformNames,\n            samplerNames: [],\n        });\n    }\n\n    public isReady(): boolean {\n        if (this._effectsAreDirty) {\n            this._createEffects();\n        }\n\n        if (!this._depthEffectWrapper || !this._thicknessEffectWrapper) {\n            return false;\n        }\n\n        const depthEffect = this._depthEffectWrapper._drawWrapper.effect!;\n        const thicknessEffect =\n            this._thicknessEffectWrapper._drawWrapper.effect!;\n\n        return depthEffect.isReady() && thicknessEffect.isReady();\n    }\n\n    public numParticles(): number {\n        return 0;\n    }\n\n    public renderDepthTexture(): void {\n        const numParticles = this.numParticles();\n\n        if (!this._depthEffectWrapper || numParticles === 0) {\n            return;\n        }\n\n        const depthDrawWrapper = this._depthEffectWrapper._drawWrapper;\n        const depthEffect = depthDrawWrapper.effect!;\n\n        this._engine.enableEffect(depthDrawWrapper);\n        this._engine.bindBuffers(\n            this.vertexBuffers,\n            this.indexBuffer,\n            depthEffect\n        );\n\n        depthEffect.setMatrix(\"view\", this._scene.getViewMatrix());\n        depthEffect.setMatrix(\"projection\", this._scene.getProjectionMatrix());\n        depthEffect.setFloat2(\"size\", this._particleSize, this._particleSize);\n        depthEffect.setFloat(\"particleRadius\", this._particleSize / 2);\n\n        if (this.useInstancing) {\n            this._engine.drawArraysType(\n                BABYLON.Constants.MATERIAL_TriangleStripDrawMode,\n                0,\n                4,\n                numParticles\n            );\n        } else {\n            this._engine.drawElementsType(\n                BABYLON.Constants.MATERIAL_TriangleFillMode,\n                0,\n                numParticles\n            );\n        }\n    }\n\n    public renderThicknessTexture(): void {\n        const numParticles = this.numParticles();\n\n        if (!this._thicknessEffectWrapper || numParticles === 0) {\n            return;\n        }\n\n        const thicknessDrawWrapper = this._thicknessEffectWrapper._drawWrapper;\n        const thicknessEffect = thicknessDrawWrapper.effect!;\n\n        this._engine.setAlphaMode(BABYLON.Constants.ALPHA_ONEONE);\n        this._engine.setDepthWrite(false);\n\n        this._engine.enableEffect(thicknessDrawWrapper);\n        this._engine.bindBuffers(\n            this.vertexBuffers,\n            this.indexBuffer,\n            thicknessEffect\n        );\n\n        thicknessEffect.setMatrix(\"view\", this._scene.getViewMatrix());\n        thicknessEffect.setMatrix(\n            \"projection\",\n            this._scene.getProjectionMatrix()\n        );\n        thicknessEffect.setFloat(\"particleAlpha\", this.particleThicknessAlpha);\n        thicknessEffect.setFloat2(\n            \"size\",\n            this._particleSize,\n            this._particleSize\n        );\n\n        if (this.useInstancing) {\n            this._engine.drawArraysType(\n                BABYLON.Constants.MATERIAL_TriangleStripDrawMode,\n                0,\n                4,\n                numParticles\n            );\n        } else {\n            this._engine.drawElementsType(\n                BABYLON.Constants.MATERIAL_TriangleFillMode,\n                0,\n                numParticles\n            );\n        }\n\n        this._engine.setDepthWrite(true);\n        this._engine.setAlphaMode(BABYLON.Constants.ALPHA_DISABLE);\n    }\n\n    public renderDiffuseTexture(): void {\n        // do nothing by default\n    }\n\n    public dispose(): void {\n        this._depthEffectWrapper?.dispose();\n        this._thicknessEffectWrapper?.dispose();\n    }\n}\n","import * as BABYLON from \"@babylonjs/core\";\n\nimport { FluidRenderingObject } from \"./fluidRenderingObject\";\n\nexport class FluidRenderingObjectParticleSystem extends FluidRenderingObject {\n    private _particleSystem: BABYLON.ParticleSystem;\n    private _renderCallback: () => number;\n    private _blendMode: number;\n    private _onBeforeDrawParticleObserver: BABYLON.Nullable<\n        BABYLON.Observer<BABYLON.Nullable<BABYLON.Effect>>\n    >;\n\n    public get particleSystem() {\n        return this._particleSystem;\n    }\n\n    public getClassName(): string {\n        return \"FluidRenderingObjectParticleSystem\";\n    }\n\n    private _useTrueRenderingForDiffuseTexture = true;\n\n    public get useTrueRenderingForDiffuseTexture() {\n        return this._useTrueRenderingForDiffuseTexture;\n    }\n\n    public set useTrueRenderingForDiffuseTexture(use: boolean) {\n        if (this._useTrueRenderingForDiffuseTexture === use) {\n            return;\n        }\n\n        this._useTrueRenderingForDiffuseTexture = use;\n\n        if (use) {\n            this._particleSystem.blendMode = this._blendMode;\n            this._particleSystem.onBeforeDrawParticlesObservable.remove(\n                this._onBeforeDrawParticleObserver\n            );\n            this._onBeforeDrawParticleObserver = null;\n        } else {\n            this._particleSystem.blendMode = -1;\n            this._onBeforeDrawParticleObserver =\n                this._particleSystem.onBeforeDrawParticlesObservable.add(() => {\n                    this._engine.setAlphaMode(BABYLON.Constants.ALPHA_COMBINE);\n                });\n        }\n    }\n\n    constructor(scene: BABYLON.Scene, ps: BABYLON.ParticleSystem) {\n        super(\n            scene,\n            ps.vertexBuffers as { [key: string]: BABYLON.VertexBuffer },\n            ps.indexBuffer\n        );\n\n        this._particleSystem = ps;\n\n        this._renderCallback = ps.render.bind(ps);\n        this._blendMode = ps.blendMode;\n        this._onBeforeDrawParticleObserver = null;\n\n        ps.render = () => 0;\n\n        this.particleSize = (ps.minSize + ps.maxSize) / 2;\n\n        this.useTrueRenderingForDiffuseTexture = false;\n    }\n\n    public isReady(): boolean {\n        return super.isReady() && this._particleSystem.isReady();\n    }\n\n    public numParticles(): number {\n        return this._particleSystem.getActiveCount();\n    }\n\n    public renderDiffuseTexture(): void {\n        this._renderCallback();\n    }\n\n    public dispose() {\n        super.dispose();\n\n        this._particleSystem.onBeforeDrawParticlesObservable.remove(\n            this._onBeforeDrawParticleObserver\n        );\n        this._onBeforeDrawParticleObserver = null;\n        this._particleSystem.render = this._renderCallback;\n        this._particleSystem.blendMode = this._blendMode;\n    }\n}\n","import * as BABYLON from \"@babylonjs/core\";\n\nimport { FluidRenderingObject } from \"./fluidRenderingObject\";\n\nexport class FluidRenderingObjectVertexBuffer extends FluidRenderingObject {\n    private _numParticles: number;\n    private _disposeVBOffset: boolean;\n    private _diffuseEffectWrapper: BABYLON.Nullable<BABYLON.EffectWrapper>;\n\n    public getClassName(): string {\n        return \"FluidRenderingObjectVertexBuffer\";\n    }\n\n    constructor(\n        scene: BABYLON.Scene,\n        vertexBuffers: { [key: string]: BABYLON.VertexBuffer },\n        numParticles: number\n    ) {\n        super(scene, vertexBuffers, null);\n\n        this._numParticles = numParticles;\n        this._disposeVBOffset = false;\n        this._diffuseEffectWrapper = null;\n\n        if (!vertexBuffers[\"offset\"]) {\n            vertexBuffers[\"offset\"] = new BABYLON.VertexBuffer(\n                this._engine,\n                [0, 0, 1, 0, 0, 1, 1, 1],\n                \"offset\",\n                false,\n                false,\n                2\n            );\n            this._disposeVBOffset = true;\n        }\n    }\n\n    protected _createEffects(): void {\n        super._createEffects();\n\n        const uniformNames = [\"view\", \"projection\", \"size\"];\n        const attributeNames = [\"position\", \"offset\", \"color\"];\n\n        this._diffuseEffectWrapper = new BABYLON.EffectWrapper({\n            engine: this._engine,\n            useShaderStore: true,\n            vertexShader: \"fluidParticleDiffuse\",\n            fragmentShader: \"fluidParticleDiffuse\",\n            attributeNames,\n            uniformNames,\n            samplerNames: [],\n        });\n    }\n\n    public isReady(): boolean {\n        return (\n            super.isReady() &&\n            (this._diffuseEffectWrapper?.effect!.isReady() ?? false)\n        );\n    }\n\n    public numParticles(): number {\n        return this._numParticles;\n    }\n\n    public setNumParticles(num: number) {\n        this._numParticles = num;\n    }\n\n    public renderDiffuseTexture(): void {\n        const numParticles = this.numParticles();\n\n        if (!this._diffuseEffectWrapper || numParticles === 0) {\n            return;\n        }\n\n        const diffuseDrawWrapper = this._diffuseEffectWrapper._drawWrapper;\n        const diffuseEffect = diffuseDrawWrapper.effect!;\n\n        this._engine.enableEffect(diffuseDrawWrapper);\n        this._engine.bindBuffers(\n            this.vertexBuffers,\n            this.indexBuffer,\n            diffuseEffect\n        );\n\n        diffuseEffect.setMatrix(\"view\", this._scene.getViewMatrix());\n        diffuseEffect.setMatrix(\n            \"projection\",\n            this._scene.getProjectionMatrix()\n        );\n        if (this._particleSize !== null) {\n            diffuseEffect.setFloat2(\n                \"size\",\n                this._particleSize,\n                this._particleSize\n            );\n        }\n\n        if (this.useInstancing) {\n            this._engine.drawArraysType(\n                BABYLON.Constants.MATERIAL_TriangleStripDrawMode,\n                0,\n                4,\n                numParticles\n            );\n        } else {\n            this._engine.drawElementsType(\n                BABYLON.Constants.MATERIAL_TriangleFillMode,\n                0,\n                numParticles\n            );\n        }\n    }\n\n    public dispose(): void {\n        super.dispose();\n\n        this._diffuseEffectWrapper?.dispose();\n\n        if (this._disposeVBOffset) {\n            this.vertexBuffers[\"offset\"].dispose();\n        }\n    }\n}\n","import * as BABYLON from \"@babylonjs/core\";\n\nexport class CopyDepthTexture {\n    private _engine: BABYLON.Engine;\n    private _width: number;\n    private _height: number;\n    private _indexBuffer: BABYLON.Nullable<BABYLON.DataBuffer>;\n    private _vertexBuffers: {\n        [key: string]: BABYLON.Nullable<BABYLON.VertexBuffer>;\n    } = {};\n    private _depthRTWrapper: BABYLON.RenderTargetWrapper;\n    private _copyEffectWrapper: BABYLON.EffectWrapper;\n\n    public get depthRTWrapper() {\n        return this._depthRTWrapper;\n    }\n\n    constructor(engine: BABYLON.Engine, width: number, height: number) {\n        this._engine = engine;\n        this._width = width;\n        this._height = height;\n\n        this._depthRTWrapper = this._engine.createRenderTargetTexture(\n            { width, height },\n            {\n                generateMipMaps: false,\n                type: BABYLON.Constants.TEXTURETYPE_UNSIGNED_BYTE,\n                format: BABYLON.Constants.TEXTUREFORMAT_R,\n                samplingMode: BABYLON.Constants.TEXTURE_NEAREST_SAMPLINGMODE,\n                generateDepthBuffer: true,\n                generateStencilBuffer: false,\n                samples: 1,\n                noColorTarget: true,\n            }\n        );\n        this._depthRTWrapper.createDepthStencilTexture(0, false, false, 1);\n\n        this._copyEffectWrapper = new BABYLON.EffectWrapper({\n            engine: this._engine,\n            useShaderStore: true,\n            vertexShader: \"passDepth\",\n            fragmentShader: \"passDepth\",\n            attributeNames: [\"position\"],\n            uniformNames: [],\n            samplerNames: [\"textureDepth\"],\n            shaderLanguage: engine.isWebGPU\n                ? BABYLON.ShaderLanguage.WGSL\n                : BABYLON.ShaderLanguage.GLSL,\n        });\n\n        // VBO\n        const vertices = [];\n        vertices.push(1, 1);\n        vertices.push(-1, 1);\n        vertices.push(-1, -1);\n        vertices.push(1, -1);\n\n        this._vertexBuffers[BABYLON.VertexBuffer.PositionKind] =\n            new BABYLON.VertexBuffer(\n                this._engine,\n                vertices,\n                BABYLON.VertexBuffer.PositionKind,\n                false,\n                false,\n                2\n            );\n\n        // Indices\n        const indices = [];\n        indices.push(0);\n        indices.push(1);\n        indices.push(2);\n\n        indices.push(0);\n        indices.push(2);\n        indices.push(3);\n\n        this._indexBuffer = this._engine.createIndexBuffer(indices);\n    }\n\n    public copy(source: BABYLON.InternalTexture): boolean {\n        const effect = this._copyEffectWrapper.effect;\n\n        if (!effect.isReady()) {\n            return false;\n        }\n\n        this._engine.bindFramebuffer(this._depthRTWrapper!);\n\n        this._engine.enableEffect(this._copyEffectWrapper._drawWrapper);\n\n        const engineDepthFunc = this._engine.getDepthFunction();\n\n        this._engine.setState(false);\n        this._engine.setDepthBuffer(true);\n        this._engine.setDepthWrite(true);\n        this._engine.setDepthFunction(BABYLON.Constants.ALWAYS);\n        this._engine.setColorWrite(false);\n\n        this._engine.bindBuffers(\n            this._vertexBuffers,\n            this._indexBuffer,\n            effect\n        );\n\n        effect._bindTexture(\"textureDepth\", source);\n\n        this._engine.drawElementsType(\n            BABYLON.Constants.MATERIAL_TriangleFillMode,\n            0,\n            6\n        );\n\n        this._engine.setDepthFunction(engineDepthFunc!);\n        this._engine.setColorWrite(true);\n\n        this._engine.unBindFramebuffer(this._depthRTWrapper!);\n\n        return true;\n    }\n\n    public dispose() {\n        this._depthRTWrapper.dispose();\n\n        this._vertexBuffers[BABYLON.VertexBuffer.PositionKind]?.dispose();\n        this._vertexBuffers = {};\n\n        if (this._indexBuffer) {\n            this._engine._releaseBuffer(this._indexBuffer);\n            this._indexBuffer = null;\n        }\n    }\n}\n"],"names":["Object","defineProperty","get","this","_renderAsFluid","set","value","_scene","fluidRenderer","collectParticleSystems","enumerable","configurable","FluidRenderer","constructor","scene","_engine","getEngine","_onEngineResizeObserver","_renderObjects","_targetRenderers","_cameras","Map","_SceneComponentInitialization","onResizeObservable","add","_initialize","renderObjects","targetRenderers","recreate","_sortRenderingObjects","getRenderObjectFromParticleSystem","ps","index","_getParticleSystemIndex","getRenderObjectFromVertexBuffer","vb","_getVertexBufferIndex","addParticleSystem","generateDiffuseTexture","targetRenderer","camera","object","FluidRenderingObjectParticleSystem","onParticleSizeChanged","_setParticleSizeForRenderTargets","bind","FluidRenderingTargetRenderer","push","onUseVelocityChanged","hasObservers","_setUseVelocityForRenderObject","undefined","renderObject","addVertexBuffer","vertexBuffers","numParticles","FluidRenderingObjectVertexBuffer","removeRenderObject","removeUnusedTargetRenderer","indexOf","dispose","splice","_removeUnusedTargetRenderers","sort","a","b","priority","i","particleSystems","length","renderAsFluid","getClassName","indexes","removed","newList","static","obj","particleSystem","_IsParticleSystemObject","_IsVertexBufferObject","cameras","initialize","renderPostProcess","list","attachPostProcess","firstPostProcess","_getFirstPostProcess","copyDepthTextures","onSizeChangedObservable","inputTexture","depthStencilTexture","createDepthStencilTexture","isStencilEnable","samples","thicknessRT","thicknessRenderTarget","renderTarget","thicknessTexture","texture","key","width","height","copyDepthTexture","CopyDepthTexture","depthRTWrapper","_shareDepth","list2","clear","particleSizes","renderingObject","curSize","Math","max","particleSize","depthRenderTarget","useVelocity","_prepareRendering","needInitialization","_render","forCamera","clearTargets","sourceCopyDepth","_bgDepthTexture","copy","render","remove","FluidRenderingObject","indexBuffer","_particleSize","particleThicknessAlpha","_useVelocity","_effectsAreDirty","_depthEffectWrapper","_thicknessEffectWrapper","size","notifyObservers","useInstancing","use","_hasVelocity","velocity","_createEffects","uniformNames","attributeNames","defines","engine","useShaderStore","vertexShader","fragmentShader","samplerNames","isReady","depthEffect","_drawWrapper","effect","thicknessEffect","renderDepthTexture","depthDrawWrapper","enableEffect","bindBuffers","setMatrix","getViewMatrix","getProjectionMatrix","setFloat2","setFloat","drawArraysType","drawElementsType","renderThicknessTexture","thicknessDrawWrapper","setAlphaMode","setDepthWrite","renderDiffuseTexture","super","_useTrueRenderingForDiffuseTexture","_particleSystem","_renderCallback","_blendMode","blendMode","_onBeforeDrawParticleObserver","minSize","maxSize","useTrueRenderingForDiffuseTexture","onBeforeDrawParticlesObservable","getActiveCount","_numParticles","_disposeVBOffset","_diffuseEffectWrapper","setNumParticles","num","diffuseDrawWrapper","diffuseEffect","_vertexBuffers","_width","_height","_depthRTWrapper","createRenderTargetTexture","generateMipMaps","type","format","samplingMode","generateDepthBuffer","generateStencilBuffer","noColorTarget","_copyEffectWrapper","shaderLanguage","isWebGPU","vertices","indices","_indexBuffer","createIndexBuffer","source","bindFramebuffer","engineDepthFunc","getDepthFunction","setState","setDepthBuffer","setDepthFunction","setColorWrite","_bindTexture","unBindFramebuffer","_releaseBuffer"],"sourceRoot":""}