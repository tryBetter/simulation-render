"use strict";(self.webpackChunkbabylonjs_fluid_rendering=self.webpackChunkbabylonjs_fluid_rendering||[]).push([[508,499,573,984,247],{5508:(e,t,r)=>{r.r(t),r.d(t,{FluidRenderer:()=>l});var n=r(6291),i=r(8573),s=r(7419),o=r(5984),a=r(247);Object.defineProperty(n.ParticleSystem.prototype,"renderAsFluid",{get:function(){return this._renderAsFluid},set:function(e){var t,r;this._renderAsFluid=e,null===(r=null===(t=this._scene)||void 0===t?void 0:t.fluidRenderer)||void 0===r||r.collectParticleSystems()},enumerable:!0,configurable:!0});class l{constructor(e){this._scene=e,this._engine=e.getEngine(),this._onEngineResizeObserver=null,this._renderObjects=[],this._targetRenderers=[],this._cameras=new Map,l._SceneComponentInitialization(this._scene),this._onEngineResizeObserver=this._engine.onResizeObservable.add((()=>{this._initialize()})),this.collectParticleSystems()}get renderObjects(){return this._renderObjects}get targetRenderers(){return this._targetRenderers}recreate(){this._sortRenderingObjects(),this._initialize()}getRenderObjectFromParticleSystem(e){const t=this._getParticleSystemIndex(e);return-1!==t?this._renderObjects[t]:null}getRenderObjectFromVertexBuffer(e){const t=this._getVertexBufferIndex(e);return-1!==t?this._renderObjects[t]:null}addParticleSystem(e,t,r,n){const o=new i.FluidRenderingObjectParticleSystem(this._scene,e);o.onParticleSizeChanged.add(this._setParticleSizeForRenderTargets.bind(this)),r||(r=new s.FluidRenderingTargetRenderer(this._scene,n),this._targetRenderers.push(r)),r.onUseVelocityChanged.hasObservers()||r.onUseVelocityChanged.add(this._setUseVelocityForRenderObject.bind(this)),void 0!==t&&(r.generateDiffuseTexture=t);const a={object:o,targetRenderer:r};return this._renderObjects.push(a),this._sortRenderingObjects(),this._setParticleSizeForRenderTargets(),a}addVertexBuffer(e,t,r,n,i){const a=new o.FluidRenderingObjectVertexBuffer(this._scene,e,t);a.onParticleSizeChanged.add(this._setParticleSizeForRenderTargets.bind(this)),n||(n=new s.FluidRenderingTargetRenderer(this._scene,i),this._targetRenderers.push(n)),n.onUseVelocityChanged.hasObservers()||n.onUseVelocityChanged.add(this._setUseVelocityForRenderObject.bind(this)),void 0!==r&&(n.generateDiffuseTexture=r);const l={object:a,targetRenderer:n};return this._renderObjects.push(l),this._sortRenderingObjects(),this._setParticleSizeForRenderTargets(),l}removeRenderObject(e,t=!0){const r=this._renderObjects.indexOf(e);return-1!==r&&(e.object.dispose(),this._renderObjects.splice(r,1),t&&this._removeUnusedTargetRenderers()?this._initialize():this._setParticleSizeForRenderTargets(),!0)}_sortRenderingObjects(){this._renderObjects.sort(((e,t)=>e.object.priority<t.object.priority?-1:e.object.priority>t.object.priority?1:0))}collectParticleSystems(){for(let e=0;e<this._scene.particleSystems.length;++e){const t=this._scene.particleSystems[e],r=this._getParticleSystemIndex(t);-1===r?t.renderAsFluid&&"ParticleSystem"===t.getClassName()&&this.addParticleSystem(t,!0):t.renderAsFluid||(this._renderObjects[r].object.dispose(),this._renderObjects.splice(r,1))}this._removeUnusedTargetRenderers(),this._initialize()}_removeUnusedTargetRenderers(){const e={};for(let t=0;t<this._renderObjects.length;++t){const r=this._renderObjects[t].targetRenderer;e[this._targetRenderers.indexOf(r)]=!0}let t=!1;const r=[];for(let n=0;n<this._targetRenderers.length;++n)e[n]?r.push(this._targetRenderers[n]):(this._targetRenderers[n].dispose(),t=!0);return t&&(this._targetRenderers.length=0,this._targetRenderers.push(...r)),t}static _IsParticleSystemObject(e){return!!e.particleSystem}static _IsVertexBufferObject(e){return"FluidRenderingObjectVertexBuffer"===e.getClassName()}_getParticleSystemIndex(e){for(let t=0;t<this._renderObjects.length;++t){const r=this._renderObjects[t].object;if(l._IsParticleSystemObject(r)&&r.particleSystem===e)return t}return-1}_getVertexBufferIndex(e){for(let t=0;t<this._renderObjects.length;++t){const r=this._renderObjects[t].object;if(l._IsVertexBufferObject(r)&&r.vertexBuffers[n.VertexBuffer.PositionKind]===e)return t}return-1}_initialize(){for(let e=0;e<this._targetRenderers.length;++e)this._targetRenderers[e].dispose();const e=new Map;for(let t=0;t<this._targetRenderers.length;++t){const r=this._targetRenderers[t];if(r.initialize(),r.camera&&r.renderPostProcess){let n=e.get(r.camera);n||(n=[[],{}],e.set(r.camera,n)),n[0].push(r),r.camera.attachPostProcess(r.renderPostProcess,t)}}for(const[t,r]of e){const e=t._getFirstPostProcess();if(!e)continue;const[n,i]=r;e.onSizeChangedObservable.add((()=>{var t;e.inputTexture.depthStencilTexture||e.inputTexture.createDepthStencilTexture(0,!0,this._engine.isStencilEnable,n[0].samples);for(const e of n){const r=null===(t=e.thicknessRenderTarget)||void 0===t?void 0:t.renderTarget,n=null==r?void 0:r.texture;if(r&&n){const e=n.width+"_"+n.height;let t=i[e];t||(t=i[e]=new a.CopyDepthTexture(this._engine,n.width,n.height)),t.depthRTWrapper._shareDepth(r)}}}))}for(const[t,r]of this._cameras){const n=r[1],i=e.get(t);if(i)for(const e in n)i[1][e]||n[e].dispose();else for(const e in n)n[e].dispose()}this._cameras.clear(),this._cameras=e,this._setParticleSizeForRenderTargets()}_setParticleSizeForRenderTargets(){const e=new Map;for(let t=0;t<this._renderObjects.length;++t){const r=this._renderObjects[t];let n=e.get(r.targetRenderer);void 0===n&&(n=0),e.set(r.targetRenderer,Math.max(n,r.object.particleSize))}for(const[t,r]of e)t.depthRenderTarget&&(t.depthRenderTarget.particleSize=r)}_setUseVelocityForRenderObject(){for(let e=0;e<this._renderObjects.length;++e){const t=this._renderObjects[e];t.object.useVelocity=t.targetRenderer.useVelocity}}_prepareRendering(){let e=!1;for(let t=0;t<this._targetRenderers.length;++t)e=e||this._targetRenderers[t].needInitialization;e&&this._initialize()}_render(e){var t;for(let t=0;t<this._targetRenderers.length;++t)e&&this._targetRenderers[t].camera!==e||this._targetRenderers[t].clearTargets();for(const[r,n]of this._cameras){if(e&&r!==e)continue;const i=r._getFirstPostProcess();if(!i)continue;const s=null===(t=i.inputTexture)||void 0===t?void 0:t.depthStencilTexture;if(s){const[e,t]=n;for(const t of e)t._bgDepthTexture=s;for(const e in t)t[e].copy(s)}}for(let t=0;t<this._renderObjects.length;++t){const r=this._renderObjects[t];e&&r.targetRenderer.camera!==e||r.targetRenderer.render(r.object)}}dispose(){this._engine.onResizeObservable.remove(this._onEngineResizeObserver),this._onEngineResizeObserver=null;for(let e=0;e<this._renderObjects.length;++e)this._renderObjects[e].object.dispose();for(let e=0;e<this._targetRenderers.length;++e)this._targetRenderers[e].dispose();for(const e of this._cameras){const t=e[1][1];for(const e in t)t[e].dispose()}this._renderObjects=[],this._targetRenderers=[],this._cameras.clear()}}l._SceneComponentInitialization=()=>{throw"FluidRendererSceneComponent needs to be imported before as it contains a side-effect required by your code."},n.ShaderStore.ShadersStore.fluidParticleDepthVertexShader="attribute vec3 position;\nattribute vec2 offset;\n\nuniform mat4 view;\nuniform mat4 projection;\nuniform vec2 size;\n\nvarying vec2 uv;\nvarying vec3 viewPos;\nvarying float sphereRadius;\n\n#ifdef FLUIDRENDERING_VELOCITY\n    attribute vec3 velocity;\n    varying float velocityNorm;\n#endif\n\nvoid main(void) {\n    vec3 cornerPos;\n    cornerPos.xy = vec2(offset.x - 0.5, offset.y - 0.5) * size;\n    cornerPos.z = 0.0;\n\n    viewPos = (view * vec4(position, 1.0)).xyz;\n\n    gl_Position = projection * vec4(viewPos + cornerPos, 1.0);\n\n    uv = offset;\n    sphereRadius = size.x / 2.0;\n#ifdef FLUIDRENDERING_VELOCITY\n    velocityNorm = length(velocity);\n#endif\n}\n",n.ShaderStore.ShadersStore.fluidParticleDepthFragmentShader="uniform mat4 projection;\n\nvarying vec2 uv;\nvarying vec3 viewPos;\nvarying float sphereRadius;\n\n#ifdef FLUIDRENDERING_VELOCITY\n    varying float velocityNorm;\n#endif\n\nvoid main(void) {\n    vec3 normal;\n\n    normal.xy = uv * 2.0 - 1.0;\n    float r2 = dot(normal.xy, normal.xy);\n    if (r2 > 1.0) discard;\n    normal.z = -sqrt(1.0 - r2);\n\n    vec4 realViewPos = vec4(viewPos + normal * sphereRadius, 1.0);\n    vec4 clipSpacePos = projection * realViewPos;\n\n#ifdef WEBGPU\n    gl_FragDepth = clipSpacePos.z / clipSpacePos.w;\n#else\n    gl_FragDepth = (clipSpacePos.z / clipSpacePos.w) * 0.5 + 0.5;\n#endif\n\n#ifdef FLUIDRENDERING_VELOCITY\n    glFragColor = vec4(realViewPos.z, velocityNorm, 0., 1.);\n#else\n    glFragColor = vec4(realViewPos.z, 0., 0., 1.);\n#endif\n}\n",n.ShaderStore.ShadersStore.fluidParticleThicknessVertexShader="attribute vec3 position;\nattribute vec2 offset;\n\nuniform mat4 view;\nuniform mat4 projection;\nuniform vec2 size;\n\nvarying vec2 uv;\n\nvoid main(void) {\n    vec3 cornerPos;\n    cornerPos.xy = vec2(offset.x - 0.5, offset.y - 0.5) * size;\n    cornerPos.z = 0.0;\n\n    vec3 viewPos = (view * vec4(position, 1.0)).xyz + cornerPos;\n\n    gl_Position = projection * vec4(viewPos, 1.0);\n\n    uv = offset;\n}\n",n.ShaderStore.ShadersStore.fluidParticleThicknessFragmentShader="uniform float particleAlpha;\n\nvarying vec2 uv;\n\nvoid main(void) {\n    vec3 normal;\n\n    normal.xy = uv * 2.0 - 1.0;\n    float r2 = dot(normal.xy, normal.xy);\n    if (r2 > 1.0) discard;\n    float thickness = sqrt(1.0 - r2);\n\n    glFragColor = vec4(vec3(particleAlpha * thickness), 1.0);\n}\n",n.ShaderStore.ShadersStore.fluidParticleDiffuseVertexShader="attribute vec3 position;\nattribute vec2 offset;\nattribute vec4 color;\n\nuniform mat4 view;\nuniform mat4 projection;\nuniform vec2 size;\n\nvarying vec2 uv;\nvarying vec3 diffuseColor;\n\nvoid main(void) {\n    vec3 cornerPos;\n    cornerPos.xy = vec2(offset.x - 0.5, offset.y - 0.5) * size;\n    cornerPos.z = 0.0;\n\n    vec3 viewPos = (view * vec4(position, 1.0)).xyz + cornerPos;\n\n    gl_Position = projection * vec4(viewPos, 1.0);\n\n    uv = offset;\n    diffuseColor = color.rgb;\n}\n",n.ShaderStore.ShadersStore.fluidParticleDiffuseFragmentShader="uniform float particleAlpha;\n\nvarying vec2 uv;\nvarying vec3 diffuseColor;\n\nvoid main(void) {\n    vec3 normal;\n\n    normal.xy = uv * 2.0 - 1.0;\n    float r2 = dot(normal.xy, normal.xy);\n    if (r2 > 1.0) discard;\n\n    glFragColor = vec4(diffuseColor, 1.0);\n}\n",n.ShaderStore.ShadersStore.bilateralBlurFragmentShader="uniform sampler2D textureSampler;\n\nuniform int maxFilterSize;\nuniform vec2 blurDir;\nuniform float projectedParticleConstant;\nuniform float depthThreshold;\n\nvarying vec2 vUV;\n\nvoid main(void) {\n    float depth = texture2D(textureSampler, vUV).x;\n\n    if (depth >= 1e6 || depth <= 0.) {\n        glFragColor = vec4(vec3(depth), 1.);\n        return;\n    }\n\n    int filterSize = min(maxFilterSize, int(ceil(projectedParticleConstant / depth)));\n    float sigma = float(filterSize) / 3.0;\n    float two_sigma2 = 2.0 * sigma * sigma;\n\n    float sigmaDepth = depthThreshold / 3.0;\n    float two_sigmaDepth2 = 2.0 * sigmaDepth * sigmaDepth;\n\n    float sum = 0.;\n    float wsum = 0.;\n    float sumVel = 0.;\n\n    for (int x = -filterSize; x <= filterSize; ++x) {\n        vec2 coords = vec2(x);\n        vec2 sampleDepthVel = texture2D(textureSampler, vUV + coords * blurDir).rg;\n\n        float r = dot(coords, coords);\n        float w = exp(-r / two_sigma2);\n\n        float rDepth = sampleDepthVel.r - depth;\n        float wd = exp(-rDepth * rDepth / two_sigmaDepth2);\n\n        sum += sampleDepthVel.r * w * wd;\n        sumVel += sampleDepthVel.g * w * wd;\n        wsum += w * wd;\n    }\n\n    glFragColor = vec4(sum / wsum, sumVel / wsum, 0., 1.);\n}\n",n.ShaderStore.ShadersStore.standardBlurFragmentShader="uniform sampler2D textureSampler;\n\nuniform int filterSize;\nuniform vec2 blurDir;\n\nvarying vec2 vUV;\n\nvoid main(void) {\n    vec4 s = texture2D(textureSampler, vUV);\n    if (s.r == 0.) {\n        glFragColor = vec4(0., 0., 0., 1.);\n        return;\n    }\n\n    float sigma = float(filterSize) / 3.0;\n    float twoSigma2 = 2.0 * sigma * sigma;\n\n    vec4 sum = vec4(0.);\n    float wsum = 0.;\n\n    for (int x = -filterSize; x <= filterSize; ++x) {\n        vec2 coords = vec2(x);\n        vec4 sampl = texture2D(textureSampler, vUV + coords * blurDir);\n\n        float w = exp(-coords.x * coords.x / twoSigma2);\n\n        sum += sampl * w;\n        wsum += w;\n    }\n\n    sum /= wsum;\n\n    glFragColor = vec4(sum.rgb, 1.);\n}\n",n.ShaderStore.ShadersStore.renderFluidFragmentShader="// Index of refraction for water\n#define IOR 1.333\n\n// Ratios of air and water IOR for refraction\n// Air to water\n#define ETA 1.0/IOR\n\n// Fresnel at 0°\n#define F0 0.02\n\nuniform sampler2D textureSampler;\nuniform sampler2D depthSampler;\n#ifdef FLUIDRENDERING_DIFFUSETEXTURE\n    uniform sampler2D diffuseSampler;\n#else\n    uniform vec3 diffuseColor;\n#endif\n#ifdef FLUIDRENDERING_FIXED_THICKNESS\n    uniform float thickness;\n    uniform sampler2D bgDepthSampler;\n#else\n    uniform float minimumThickness;\n    uniform sampler2D thicknessSampler;\n#endif\nuniform samplerCube reflectionSampler;\n#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_TEXTURE)\n    uniform sampler2D debugSampler;\n#endif\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 invProjectionMatrix;\nuniform vec2 texelSize;\nuniform vec3 dirLight;\nuniform float cameraFar;\nuniform float density;\nuniform float refractionStrength;\nuniform float fresnelClamp;\nuniform float specularPower;\nuniform vec3 surfaceColor;\n\nvarying vec2 vUV;\n\nvec3 computeViewPosFromUVDepth(vec2 texCoord, float depth) {\n    vec4 ndc;\n    \n    ndc.xy = texCoord * 2.0 - 1.0;\n    ndc.z = projectionMatrix[2].z + projectionMatrix[3].z / depth;\n    ndc.w = 1.0;\n\n    vec4 eyePos = invProjectionMatrix * ndc;\n    eyePos.xyz /= eyePos.w;\n\n    return eyePos.xyz;\n}\n\nvec3 getViewPosFromTexCoord(vec2 texCoord) {\n    float depth = texture2D(depthSampler, texCoord).x;\n    return computeViewPosFromUVDepth(texCoord, depth);\n}\n\nvoid main(void) {\n    vec2 texCoord = vUV;\n\n#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_TEXTURE)\n    vec4 color = texture2D(debugSampler, texCoord);\n    #ifdef FLUIDRENDERING_DEBUG_DEPTH\n        glFragColor = vec4(color.rgb / vec3(2.0), 1.);\n        if (color.r > 0.999 && color.g > 0.999) {\n            glFragColor = texture2D(textureSampler, texCoord);\n        }\n    #else\n        glFragColor = vec4(color.rgb, 1.);\n        if (color.r < 0.001 && color.g < 0.001 && color.b < 0.001) {\n            glFragColor = texture2D(textureSampler, texCoord);\n        }\n    #endif\n    return;\n#endif\n\n    vec2 depthVel = texture2D(depthSampler, texCoord).rg;\n    float depth = depthVel.r;\n#ifndef FLUIDRENDERING_FIXED_THICKNESS\n    float thickness = texture2D(thicknessSampler, texCoord).x;\n#else\n    float bgDepth = texture2D(bgDepthSampler, texCoord).x;\n    float depthNonLinear = projectionMatrix[2].z + projectionMatrix[3].z / depth;\n    depthNonLinear = depthNonLinear * 0.5 + 0.5;\n#endif\n\n#ifndef FLUIDRENDERING_FIXED_THICKNESS\n    if (depth >= cameraFar || depth <= 0. || thickness <= minimumThickness) {\n#else\n    if (depth >= cameraFar || depth <= 0. || bgDepth <= depthNonLinear) {\n#endif\n//        vec3 backColor = texture2D(textureSampler, texCoord).rgb;\n        glFragColor = texture2D(textureSampler, texCoord);\n        return;\n    }\n\n    // calculate view-space position from depth\n    vec3 viewPos = computeViewPosFromUVDepth(texCoord, depth);\n\n    // calculate normal\n    vec3 ddx = getViewPosFromTexCoord(texCoord + vec2(texelSize.x, 0.)) - viewPos;\n    vec3 ddy = getViewPosFromTexCoord(texCoord + vec2(0., texelSize.y)) - viewPos;\n\n    vec3 ddx2 = viewPos - getViewPosFromTexCoord(texCoord + vec2(-texelSize.x, 0.));\n    if (abs(ddx.z) > abs(ddx2.z)) {\n        ddx = ddx2;\n    }\n\n    vec3 ddy2 = viewPos - getViewPosFromTexCoord(texCoord + vec2(0., -texelSize.y));\n    if (abs(ddy.z) > abs(ddy2.z)) {\n        ddy = ddy2;\n    }\n\n    vec3 normal = normalize(cross(ddy, ddx));\n    if(isnan(normal.x) || isnan(normal.y) || isnan(normal.z) ||\n    isinf(normal.x) || isinf(normal.y) || isinf(normal.z)) {\n        normal = vec3(0., 0., -1.);\n    }\n\n#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_SHOWNORMAL)\n    glFragColor = vec4(normal * 0.5 + 0.5, 1.0);\n    return;\n#endif\n\n    // shading\n    vec3 rayDir = normalize(viewPos); // direction from camera position to view position\n\n#ifdef FLUIDRENDERING_DIFFUSETEXTURE\n    vec3 diffuseColor = texture2D(diffuseSampler, texCoord).rgb;\n#endif\n\n    vec3  lightDir = normalize(vec3(viewMatrix * vec4(-dirLight, 0.)));\n    vec3  H        = normalize(lightDir - rayDir);\n    float specular = pow(max(0.0, dot(H, normal)), specularPower);\n\n#ifdef FLUIDRENDERING_DEBUG_DIFFUSERENDERING\n    float diffuse  = max(0.0, dot(lightDir, normal)) * 1.0;\n\n    glFragColor = vec4(vec3(0.1) /*ambient*/ + vec3(0.42, 0.50, 1.00) * diffuse + vec3(0, 0, 0.2) + specular, 0.0);\n    return;\n#endif\n\n    // Refraction color\n    vec3 refractionDir = refract(rayDir, normal, ETA);\n\n    vec3 transmitted = (texture2D(textureSampler, vec2(texCoord + refractionDir.xy * thickness * refractionStrength)).rgb);\n    vec3 transmittance = exp(-density * thickness * (1.0 - diffuseColor)); // Beer law\n   \n    vec3 refractionColor = transmitted * transmittance;\n\n    // Reflection of the environment.\n    vec3 reflectionDir = reflect(rayDir, normal);\n    vec3 reflectionColor = (textureCube(reflectionSampler, reflectionDir).rgb);\n\n    // Combine refraction and reflection    \n    float fresnel = clamp(F0 + (1.0 - F0) * pow(1.0 - dot(normal, -rayDir), 5.0), 0., fresnelClamp);\n    \n    vec3 finalColor = mix(refractionColor, reflectionColor, fresnel) + specular;\n\n#ifdef FLUIDRENDERING_VELOCITY\n    float velocity = depthVel.g;\n    finalColor = mix(finalColor, vec3(1.0), smoothstep(0.3, 1.0, velocity / 6.0));\n#endif\n    \n    glFragColor = vec4(mix(finalColor, surfaceColor, dot(lightDir, normal) > 0.1 ? dot(lightDir, normal) : 0.0), 1.);\n//    glFragColor = vec4(finalColor, 1.);\n}\n",n.ShaderStore.ShadersStoreWGSL.renderFluidFragmentShader="// Index of refraction for water\nlet IOR = 1.333;\n\n// Ratios of air and water IOR for refraction\n// Air to water\nlet ETA = 0.7501875468867217; // 1.0 / IOR;\n\n// Fresnel at 0°\nlet F0 = 0.02;\n\nvar textureSampler : texture_2d<f32>;\nvar textureSamplerSampler : sampler;\nvar depthSampler : texture_2d<f32>;\n#ifdef FLUIDRENDERING_DIFFUSETEXTURE\n    var diffuseSampler : texture_2d<f32>;\n    var diffuseSamplerSampler : sampler;\n#else\n    uniform diffuseColor : vec3<f32>;\n#endif\n#ifdef FLUIDRENDERING_FIXED_THICKNESS\n    uniform thickness : f32;\n    var bgDepthSampler: texture_depth_2d;\n    var bgDepthSamplerSampler: sampler;\n#else\n    uniform minimumThickness : f32;\n    var thicknessSampler : texture_2d<f32>;\n    var thicknessSamplerSampler : sampler;\n#endif\nvar reflectionSampler : texture_cube<f32>;\nvar reflectionSamplerSampler : sampler;\n#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_TEXTURE)\n    var debugSampler : texture_2d<f32>;\n    var debugSamplerSampler : sampler;\n#endif\n\nuniform viewMatrix : mat4x4<f32>;\nuniform projectionMatrix : mat4x4<f32>;\nuniform invProjectionMatrix : mat4x4<f32>;\nuniform texelSize : vec2<f32>;\nuniform dirLight : vec3<f32>;\nuniform cameraFar : f32;\nuniform density : f32;\nuniform refractionStrength : f32;\nuniform fresnelClamp : f32;\nuniform specularPower : f32;\n\nvarying vUV : vec2<f32>;\n\nfn computeViewPosFromUVDepth(texCoord : vec2<f32>, depth : f32) -> vec3<f32> {\n    let ndc = vec4(texCoord * 2.0 - 1.0, uniforms.projectionMatrix[2].z + uniforms.projectionMatrix[3].z / depth, 1.0);\n\n    var eyePos = uniforms.invProjectionMatrix * ndc;\n\n    return eyePos.xyz / eyePos.w;\n}\n\nfn getViewPosFromTexCoord(texCoord : vec2<f32>) -> vec3<f32> {\n    let dim = textureDimensions(depthSampler);\n    let depth = textureLoad(depthSampler, vec2<i32>(texCoord * vec2<f32>(dim)), 0).x;\n    return computeViewPosFromUVDepth(texCoord, depth);\n}\n\n@stage(fragment)\nfn main(input: FragmentInputs) -> FragmentOutputs {\n    let texCoord = vUV;\n\n#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_TEXTURE)\n    #ifdef FLUIDRENDERING_DEBUG_DEPTH\n        let dim2 = textureDimensions(debugSampler);\n        let color = textureLoad(debugSampler, vec2<i32>(texCoord * vec2<f32>(dim2)), 0);\n        gl_FragColor = vec4(color.rgb / 2.0, 1.);\n        if (color.r > 0.999 && color.g > 0.999) {\n            gl_FragColor = textureSample(textureSampler, textureSamplerSampler, texCoord);\n        }\n    #else\n        let color = textureSample(debugSampler, debugSamplerSampler, texCoord);\n        gl_FragColor = vec4(color.rgb, 1.);\n        if (color.r < 0.001 && color.g < 0.001 && color.b < 0.001) {\n            gl_FragColor = textureSample(textureSampler, textureSamplerSampler, texCoord);\n        }\n    #endif\n    output.color = gl_FragColor;\n    return output;\n#endif\n\n    let dim = textureDimensions(depthSampler);\n    let depthVel = textureLoad(depthSampler, vec2<i32>(texCoord * vec2<f32>(dim)), 0).rg;\n    let depth = depthVel.r;\n#ifndef FLUIDRENDERING_FIXED_THICKNESS\n    let thickness_ = textureSample(thicknessSampler, thicknessSamplerSampler, texCoord).x;\n#else\n    let bgDepth = textureSample(bgDepthSampler, bgDepthSamplerSampler, texCoord);\n    let depthNonLinear = uniforms.projectionMatrix[2].z + uniforms.projectionMatrix[3].z / depth;\n    let thickness_ = uniforms.thickness;\n#endif\n    let thickness = thickness_;\n\n#ifndef FLUIDRENDERING_FIXED_THICKNESS\n    if (depth >= uniforms.cameraFar || depth <= 0. || thickness <= uniforms.minimumThickness) {\n#else\n    if (depth >= uniforms.cameraFar || depth <= 0. || bgDepth <= depthNonLinear) {\n#endif\n        let backColor = textureSample(textureSampler, textureSamplerSampler, texCoord).rgb;\n        gl_FragColor = vec4(backColor, 1.);\n        output.color = gl_FragColor;\n        return output;\n    }\n\n    // calculate view-space position from depth\n    let viewPos = computeViewPosFromUVDepth(texCoord, depth);\n\n    // calculate normal\n    var ddx = getViewPosFromTexCoord(texCoord + vec2(uniforms.texelSize.x, 0.)) - viewPos;\n    var ddy = getViewPosFromTexCoord(texCoord + vec2(0., uniforms.texelSize.y)) - viewPos;\n\n    let ddx2 = viewPos - getViewPosFromTexCoord(texCoord + vec2(-uniforms.texelSize.x, 0.));\n    if (abs(ddx.z) > abs(ddx2.z)) {\n        ddx = ddx2;\n    }\n\n    let ddy2 = viewPos - getViewPosFromTexCoord(texCoord + vec2(0., -uniforms.texelSize.y));\n    if (abs(ddy.z) > abs(ddy2.z)) {\n        ddy = ddy2;\n    }\n\n    let normal = normalize(cross(ddy, ddx));\n\n#if defined(FLUIDRENDERING_DEBUG) && defined(FLUIDRENDERING_DEBUG_SHOWNORMAL)\n    gl_FragColor = vec4(normal * 0.5 + 0.5, 1.0);\n    output.color = gl_FragColor;\n    return output;\n#endif\n\n    // shading\n    let rayDir = normalize(viewPos); // direction from camera position to view position\n\n#ifdef FLUIDRENDERING_DIFFUSETEXTURE\n    let diffuseColor_ = textureSample(diffuseSampler, diffuseSamplerSampler, texCoord).rgb;\n#else\n    let diffuseColor_ = uniforms.diffuseColor;\n#endif\n    let diffuseColor = diffuseColor_;\n\n    let  lightDir = normalize((uniforms.viewMatrix * vec4(-uniforms.dirLight, 0.)).xyz);\n    let  H        = normalize(lightDir - rayDir);\n    let specular = pow(max(0.0, dot(H, normal)), uniforms.specularPower);\n\n#ifdef FLUIDRENDERING_DEBUG_DIFFUSERENDERING\n    let diffuse  = max(0.0, dot(lightDir, normal)) * 1.0;\n\n    gl_FragColor = vec4(vec3(0.1) + vec3(0.42, 0.50, 1.00) * diffuse + vec3(0, 0, 0.2) + specular, 1.);\n    output.color = gl_FragColor;\n    return output;\n#endif\n\n    // Refraction color\n    let refractionDir = refract(rayDir, normal, ETA);\n\n    let transmitted = (textureSample(textureSampler, textureSamplerSampler, vec2(texCoord + refractionDir.xy * thickness * uniforms.refractionStrength)).rgb);\n    let transmittance = exp(-uniforms.density * thickness * (1.0 - diffuseColor)); // Beer law\n   \n    let refractionColor = transmitted * transmittance;\n\n    // Reflection of the environment.\n    let reflectionDir = reflect(rayDir, normal);\n    let reflectionColor = textureSample(reflectionSampler, reflectionSamplerSampler, reflectionDir).rgb;\n\n    // Combine refraction and reflection    \n    let fresnel = clamp(F0 + (1.0 - F0) * pow(1.0 - dot(normal, -rayDir), 5.0), 0., uniforms.fresnelClamp);\n    \n    var finalColor = mix(refractionColor, reflectionColor, fresnel) + specular;\n\n#ifdef FLUIDRENDERING_VELOCITY\n    let velocity = depthVel.g;\n    finalColor = mix(finalColor, vec3(1.0), smoothstep(0.3, 1.0, velocity / 6.0));\n#endif\n\n    gl_FragColor = vec4(finalColor, 1.);\n}\n",n.ShaderStore.ShadersStore.passDepthVertexShader="attribute vec2 position;\n\nvarying vec2 vUV;\n\nconst vec2 madd = vec2(0.5, 0.5);\n\nvoid main(void) {\n\tvUV = position * madd + madd;\n\tgl_Position = vec4(position, 0.0, 1.0);\n}\n",n.ShaderStore.ShadersStore.passDepthFragmentShader="uniform sampler2D textureDepth;\n\nvarying vec2 vUV;\n\nvoid main(void) \n{\n\tgl_FragDepth = texture2D(textureDepth, vUV).x;\n}\n",n.ShaderStore.ShadersStoreWGSL.passDepthVertexShader="attribute position: vec2<f32>;\n\nvarying vUV: vec2<f32>;\n\nlet madd = vec2(0.5, 0.5);\n\n@stage(vertex)\nfn main(input : VertexInputs) -> FragmentInputs\n{\n\tvUV = position * madd + madd;\n\tgl_Position = vec4(position, 0.0, 1.0);\n}\n",n.ShaderStore.ShadersStoreWGSL.passDepthFragmentShader="var textureDepth: texture_depth_2d;\nvar textureDepthSampler: sampler;\n\nvarying vUV: vec2<f32>;\n\n@stage(fragment)\nfn main(input: FragmentInputs) -> FragmentOutputs\n{\n\tgl_FragDepth = textureSample(textureDepth, textureDepthSampler, vUV);\n}\n",n.ShaderStore.ShadersStoreWGSL.postprocessVertexShader="// Attributes\nattribute position : vec2<f32>;\n\nuniform scale : vec2<f32>;\n// Output\nvarying vUV : vec2<f32>;\n\nlet madd = vec2(0.5, 0.5);\n\n#define CUSTOM_VERTEX_DEFINITIONS\n\n@stage(vertex)\nfn main(input : VertexInputs) -> FragmentInputs\n{\n#define CUSTOM_VERTEX_MAIN_BEGIN\n\n\tvUV = (position * madd + madd) * uniforms.scale;\n\tgl_Position = vec4(position, 0.0, 1.0);\n\n#define CUSTOM_VERTEX_MAIN_END\n}\n"},7499:(e,t,r)=>{r.r(t),r.d(t,{FluidRenderingObject:()=>i});var n=r(6291);class i{constructor(e,t,r){this.vertexBuffers=t,this.indexBuffer=r,this.priority=0,this._particleSize=.1,this.onParticleSizeChanged=new n.Observable,this.particleThicknessAlpha=.05,this._useVelocity=!0,this._scene=e,this._engine=e.getEngine(),this._effectsAreDirty=!0,this._depthEffectWrapper=null,this._thicknessEffectWrapper=null}get particleSize(){return this._particleSize}set particleSize(e){e!==this._particleSize&&(this._particleSize=e,this.onParticleSizeChanged.notifyObservers(this))}get useInstancing(){return!this.indexBuffer}get useVelocity(){return this._useVelocity}set useVelocity(e){this._useVelocity!==e&&this._hasVelocity()&&(this._useVelocity=e,this._effectsAreDirty=!0)}_hasVelocity(){return!!this.vertexBuffers.velocity}getClassName(){return"FluidRenderingObject"}_createEffects(){const e=["view","projection","particleRadius","size"],t=["position","offset"],r=[];this._effectsAreDirty=!1,this.useVelocity&&(t.push("velocity"),r.push("#define FLUIDRENDERING_VELOCITY")),this._depthEffectWrapper=new n.EffectWrapper({engine:this._engine,useShaderStore:!0,vertexShader:"fluidParticleDepth",fragmentShader:"fluidParticleDepth",attributeNames:t,uniformNames:e,samplerNames:[],defines:r}),e.push("particleAlpha"),this._thicknessEffectWrapper=new n.EffectWrapper({engine:this._engine,useShaderStore:!0,vertexShader:"fluidParticleThickness",fragmentShader:"fluidParticleThickness",attributeNames:["position","offset"],uniformNames:e,samplerNames:[]})}isReady(){if(this._effectsAreDirty&&this._createEffects(),!this._depthEffectWrapper||!this._thicknessEffectWrapper)return!1;const e=this._depthEffectWrapper._drawWrapper.effect,t=this._thicknessEffectWrapper._drawWrapper.effect;return e.isReady()&&t.isReady()}numParticles(){return 0}renderDepthTexture(){const e=this.numParticles();if(!this._depthEffectWrapper||0===e)return;const t=this._depthEffectWrapper._drawWrapper,r=t.effect;this._engine.enableEffect(t),this._engine.bindBuffers(this.vertexBuffers,this.indexBuffer,r),r.setMatrix("view",this._scene.getViewMatrix()),r.setMatrix("projection",this._scene.getProjectionMatrix()),r.setFloat2("size",this._particleSize,this._particleSize),r.setFloat("particleRadius",this._particleSize/2),this.useInstancing?this._engine.drawArraysType(n.Constants.MATERIAL_TriangleStripDrawMode,0,4,e):this._engine.drawElementsType(n.Constants.MATERIAL_TriangleFillMode,0,e)}renderThicknessTexture(){const e=this.numParticles();if(!this._thicknessEffectWrapper||0===e)return;const t=this._thicknessEffectWrapper._drawWrapper,r=t.effect;this._engine.setAlphaMode(n.Constants.ALPHA_ONEONE),this._engine.setDepthWrite(!1),this._engine.enableEffect(t),this._engine.bindBuffers(this.vertexBuffers,this.indexBuffer,r),r.setMatrix("view",this._scene.getViewMatrix()),r.setMatrix("projection",this._scene.getProjectionMatrix()),r.setFloat("particleAlpha",this.particleThicknessAlpha),r.setFloat2("size",this._particleSize,this._particleSize),this.useInstancing?this._engine.drawArraysType(n.Constants.MATERIAL_TriangleStripDrawMode,0,4,e):this._engine.drawElementsType(n.Constants.MATERIAL_TriangleFillMode,0,e),this._engine.setDepthWrite(!0),this._engine.setAlphaMode(n.Constants.ALPHA_DISABLE)}renderDiffuseTexture(){}dispose(){var e,t;null===(e=this._depthEffectWrapper)||void 0===e||e.dispose(),null===(t=this._thicknessEffectWrapper)||void 0===t||t.dispose()}}},8573:(e,t,r)=>{r.r(t),r.d(t,{FluidRenderingObjectParticleSystem:()=>s});var n=r(6291),i=r(7499);class s extends i.FluidRenderingObject{constructor(e,t){super(e,t.vertexBuffers,t.indexBuffer),this._useTrueRenderingForDiffuseTexture=!0,this._particleSystem=t,this._renderCallback=t.render.bind(t),this._blendMode=t.blendMode,this._onBeforeDrawParticleObserver=null,t.render=()=>0,this.particleSize=(t.minSize+t.maxSize)/2,this.useTrueRenderingForDiffuseTexture=!1}get particleSystem(){return this._particleSystem}getClassName(){return"FluidRenderingObjectParticleSystem"}get useTrueRenderingForDiffuseTexture(){return this._useTrueRenderingForDiffuseTexture}set useTrueRenderingForDiffuseTexture(e){this._useTrueRenderingForDiffuseTexture!==e&&(this._useTrueRenderingForDiffuseTexture=e,e?(this._particleSystem.blendMode=this._blendMode,this._particleSystem.onBeforeDrawParticlesObservable.remove(this._onBeforeDrawParticleObserver),this._onBeforeDrawParticleObserver=null):(this._particleSystem.blendMode=-1,this._onBeforeDrawParticleObserver=this._particleSystem.onBeforeDrawParticlesObservable.add((()=>{this._engine.setAlphaMode(n.Constants.ALPHA_COMBINE)}))))}isReady(){return super.isReady()&&this._particleSystem.isReady()}numParticles(){return this._particleSystem.getActiveCount()}renderDiffuseTexture(){this._renderCallback()}dispose(){super.dispose(),this._particleSystem.onBeforeDrawParticlesObservable.remove(this._onBeforeDrawParticleObserver),this._onBeforeDrawParticleObserver=null,this._particleSystem.render=this._renderCallback,this._particleSystem.blendMode=this._blendMode}}},5984:(e,t,r)=>{r.r(t),r.d(t,{FluidRenderingObjectVertexBuffer:()=>s});var n=r(6291),i=r(7499);class s extends i.FluidRenderingObject{constructor(e,t,r){super(e,t,null),this._numParticles=r,this._disposeVBOffset=!1,this._diffuseEffectWrapper=null,t.offset||(t.offset=new n.VertexBuffer(this._engine,[0,0,1,0,0,1,1,1],"offset",!1,!1,2),this._disposeVBOffset=!0)}getClassName(){return"FluidRenderingObjectVertexBuffer"}_createEffects(){super._createEffects(),this._diffuseEffectWrapper=new n.EffectWrapper({engine:this._engine,useShaderStore:!0,vertexShader:"fluidParticleDiffuse",fragmentShader:"fluidParticleDiffuse",attributeNames:["position","offset","color"],uniformNames:["view","projection","size"],samplerNames:[]})}isReady(){var e,t;return super.isReady()&&null!==(t=null===(e=this._diffuseEffectWrapper)||void 0===e?void 0:e.effect.isReady())&&void 0!==t&&t}numParticles(){return this._numParticles}setNumParticles(e){this._numParticles=e}renderDiffuseTexture(){const e=this.numParticles();if(!this._diffuseEffectWrapper||0===e)return;const t=this._diffuseEffectWrapper._drawWrapper,r=t.effect;this._engine.enableEffect(t),this._engine.bindBuffers(this.vertexBuffers,this.indexBuffer,r),r.setMatrix("view",this._scene.getViewMatrix()),r.setMatrix("projection",this._scene.getProjectionMatrix()),null!==this._particleSize&&r.setFloat2("size",this._particleSize,this._particleSize),this.useInstancing?this._engine.drawArraysType(n.Constants.MATERIAL_TriangleStripDrawMode,0,4,e):this._engine.drawElementsType(n.Constants.MATERIAL_TriangleFillMode,0,e)}dispose(){var e;super.dispose(),null===(e=this._diffuseEffectWrapper)||void 0===e||e.dispose(),this._disposeVBOffset&&this.vertexBuffers.offset.dispose()}}},247:(e,t,r)=>{r.r(t),r.d(t,{CopyDepthTexture:()=>i});var n=r(6291);class i{constructor(e,t,r){this._vertexBuffers={},this._engine=e,this._width=t,this._height=r,this._depthRTWrapper=this._engine.createRenderTargetTexture({width:t,height:r},{generateMipMaps:!1,type:n.Constants.TEXTURETYPE_UNSIGNED_BYTE,format:n.Constants.TEXTUREFORMAT_R,samplingMode:n.Constants.TEXTURE_NEAREST_SAMPLINGMODE,generateDepthBuffer:!0,generateStencilBuffer:!1,samples:1,noColorTarget:!0}),this._depthRTWrapper.createDepthStencilTexture(0,!1,!1,1),this._copyEffectWrapper=new n.EffectWrapper({engine:this._engine,useShaderStore:!0,vertexShader:"passDepth",fragmentShader:"passDepth",attributeNames:["position"],uniformNames:[],samplerNames:["textureDepth"],shaderLanguage:e.isWebGPU?n.ShaderLanguage.WGSL:n.ShaderLanguage.GLSL});const i=[];i.push(1,1),i.push(-1,1),i.push(-1,-1),i.push(1,-1),this._vertexBuffers[n.VertexBuffer.PositionKind]=new n.VertexBuffer(this._engine,i,n.VertexBuffer.PositionKind,!1,!1,2);const s=[];s.push(0),s.push(1),s.push(2),s.push(0),s.push(2),s.push(3),this._indexBuffer=this._engine.createIndexBuffer(s)}get depthRTWrapper(){return this._depthRTWrapper}copy(e){const t=this._copyEffectWrapper.effect;if(!t.isReady())return!1;this._engine.bindFramebuffer(this._depthRTWrapper),this._engine.enableEffect(this._copyEffectWrapper._drawWrapper);const r=this._engine.getDepthFunction();return this._engine.setState(!1),this._engine.setDepthBuffer(!0),this._engine.setDepthWrite(!0),this._engine.setDepthFunction(n.Constants.ALWAYS),this._engine.setColorWrite(!1),this._engine.bindBuffers(this._vertexBuffers,this._indexBuffer,t),t._bindTexture("textureDepth",e),this._engine.drawElementsType(n.Constants.MATERIAL_TriangleFillMode,0,6),this._engine.setDepthFunction(r),this._engine.setColorWrite(!0),this._engine.unBindFramebuffer(this._depthRTWrapper),!0}dispose(){var e;this._depthRTWrapper.dispose(),null===(e=this._vertexBuffers[n.VertexBuffer.PositionKind])||void 0===e||e.dispose(),this._vertexBuffers={},this._indexBuffer&&(this._engine._releaseBuffer(this._indexBuffer),this._indexBuffer=null)}}}}]);
//# sourceMappingURL=508.dddedbfdd727d397444d.js.map