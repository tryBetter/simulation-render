{"version":3,"file":"179.a90587f7b6df860da2f1.js","mappings":"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","sources":["webpack://babylonjs-fluid-rendering/./src/assets/materials/sulphuric-rock_albedo.png","webpack://babylonjs-fluid-rendering/./src/assets/materials/sulphuric-rock_roughness.png","webpack://babylonjs-fluid-rendering/./src/assets/materials/sulphuric-rock_normal-ogl.png","webpack://babylonjs-fluid-rendering/./src/assets/materials/Marble08_1K_BaseColor.png","webpack://babylonjs-fluid-rendering/./src/scenes/Utils/sdfHelper.ts"],"sourcesContent":["export default __webpack_public_path__ + \"1927c2ee10e174350b0f2680480bac03.png\";","export default __webpack_public_path__ + \"42501ae63687985d3bdf75e684bf30b8.png\";","export default __webpack_public_path__ + \"de78498b6fd56d907b099104d11e9a2a.png\";","export default __webpack_public_path__ + \"cb9384751f5882e7f6eb9f8d4f333114.png\";","import * as BABYLON from \"@babylonjs/core\";\n\n// Textures from https://freepbr.com/materials/sulphuric-rock/\nimport rockBaseColor from \"../../assets/materials/sulphuric-rock_albedo.png\";\nimport rockRoughness from \"../../assets/materials/sulphuric-rock_roughness.png\";\nimport rockNormal from \"../../assets/materials/sulphuric-rock_normal-ogl.png\";\n\nimport marbleBaseColor from \"../../assets/materials/Marble08_1K_BaseColor.png\";\n\nconst eps = 0.0001;\n\nconst eps1 = new BABYLON.Vector3(eps, -eps, -eps);\nconst eps2 = new BABYLON.Vector3(-eps, -eps, eps);\nconst eps3 = new BABYLON.Vector3(-eps, eps, -eps);\nconst eps4 = new BABYLON.Vector3(eps, eps, eps);\n\nconst dir1 = new BABYLON.Vector3(1, -1, -1);\nconst dir2 = new BABYLON.Vector3(-1, -1, 1);\nconst dir3 = new BABYLON.Vector3(-1, 1, -1);\nconst dir4 = new BABYLON.Vector3(1, 1, 1);\n\nexport interface SDFArray {\n    origin: BABYLON.Vector3;\n    dimX: number;\n    dimY: number;\n    dimZ: number;\n    step: number;\n    data: number[];\n}\n\nexport interface ICollisionShape {\n    params: Array<any>;\n    sdEvaluate: (p: BABYLON.Vector3, ...args: any[]) => number;\n    computeNormal: (\n        pos: BABYLON.Vector3,\n        shape: ICollisionShape,\n        normal: BABYLON.Vector3\n    ) => void;\n    createMesh?: (\n        scene: BABYLON.Scene,\n        shape: ICollisionShape,\n        ...args: any[]\n    ) => Promise<BABYLON.Mesh>;\n    transf: BABYLON.Matrix;\n    invTransf: BABYLON.Matrix;\n    scale: number;\n    position?: BABYLON.Vector3;\n    rotation?: BABYLON.Vector3;\n    rotationQuaternion?: BABYLON.Quaternion;\n    mesh?: BABYLON.Mesh;\n    dragPlane: BABYLON.Nullable<BABYLON.Vector3>;\n    disabled?: boolean;\n    collisionRestitution?: number;\n}\n\nexport class SDFHelper {\n    public static CreateBox(\n        scene: BABYLON.Scene,\n        shape: ICollisionShape,\n        extents: BABYLON.Vector3\n    ) {\n        const box = BABYLON.MeshBuilder.CreateBox(\n            \"box\",\n            {\n                width: extents.x * 2,\n                height: extents.y * 2,\n                depth: extents.z * 2,\n            },\n            scene\n        );\n\n        const material = new BABYLON.PBRMaterial(\"boxMat\", scene);\n\n        material.metallic = 0;\n        material.roughness = 0.9;\n        material.albedoTexture = new BABYLON.Texture(\n            \"https://playground.babylonjs.com/textures/wood.jpg\",\n            scene\n        );\n        material.cullBackFaces = true;\n\n        box.material = material;\n\n        return Promise.resolve(box);\n    }\n\n    public static CreateSphere(\n        scene: BABYLON.Scene,\n        shape: ICollisionShape,\n        s: number\n    ) {\n        const sphere = BABYLON.MeshBuilder.CreateSphere(\n            \"sphere\",\n            { diameter: s * 2, segments: 16 },\n            scene\n        );\n\n        const material = new BABYLON.PBRMaterial(\"sphereMat\", scene);\n\n        material.metallic = 1;\n        material.roughness = 0.05;\n        material.albedoTexture = new BABYLON.Texture(marbleBaseColor, scene);\n        material.cullBackFaces = true;\n\n        sphere.material = material;\n\n        return Promise.resolve(sphere);\n    }\n\n    public static CreateCutHollowSphere(\n        scene: BABYLON.Scene,\n        shape: ICollisionShape,\n        radius: number,\n        planeDist: number,\n        thickness: number,\n        segments: number\n    ) {\n        thickness = thickness / radius;\n\n        const sphere = BABYLON.MeshBuilder.CreateSphere(\n            \"sphere\",\n            { diameter: radius * 2, segments },\n            scene\n        );\n        const plane = BABYLON.MeshBuilder.CreatePlane(\n            \"plane\",\n            { size: radius * 2 },\n            scene\n        );\n\n        plane.rotation.y = Math.PI / 2;\n        plane.position.x = planeDist;\n\n        const csg1 = BABYLON.CSG.FromMesh(sphere);\n        const csgp = BABYLON.CSG.FromMesh(plane);\n\n        sphere.dispose();\n        plane.dispose();\n\n        csg1.subtractInPlace(csgp);\n\n        const mesh = csg1.toMesh(\"sppl\");\n\n        mesh.computeWorldMatrix(true);\n        mesh.refreshBoundingInfo();\n\n        mesh.scaling.setAll(1 - thickness);\n        mesh.position.x =\n            mesh.getBoundingInfo().boundingBox.maximumWorld.x * thickness;\n\n        const csg2 = BABYLON.CSG.FromMesh(mesh);\n\n        mesh.dispose();\n\n        csg1.subtractInPlace(csg2);\n\n        const meshFinal = csg1.toMesh(\"cutHollowSphere\");\n\n        meshFinal.rotation.z = Math.PI / 2;\n        meshFinal.bakeCurrentTransformIntoVertices();\n\n        const material = new BABYLON.PBRMaterial(\"cutHollowSphereMat\", scene);\n\n        material.metallic = 1;\n        material.roughness = 0.05;\n        material.albedoTexture = new BABYLON.Texture(marbleBaseColor, scene);\n        material.cullBackFaces = true;\n\n        meshFinal.material = material;\n\n        return Promise.resolve(meshFinal);\n    }\n\n    public static CreateVerticalCylinder(\n        scene: BABYLON.Scene,\n        shape: ICollisionShape,\n        r: number,\n        h: number,\n        segments: number\n    ) {\n        const cylinder = BABYLON.MeshBuilder.CreateCylinder(\n            \"cylinder\",\n            { diameter: r * 2, height: h, tessellation: segments },\n            scene\n        );\n\n        const material = new BABYLON.PBRMaterial(\"cylinderMat\", scene);\n\n        material.metallic = 1;\n        material.roughness = 0.05;\n        material.albedoTexture = new BABYLON.Texture(marbleBaseColor, scene);\n        material.cullBackFaces = true;\n\n        cylinder.material = material;\n\n        return Promise.resolve(cylinder);\n    }\n\n    public static CreateTerrain(\n        scene: BABYLON.Scene,\n        shape: ICollisionShape,\n        size: number\n    ) {\n        const ground = BABYLON.MeshBuilder.CreateGroundFromHeightMap(\n            \"terrain\",\n            \"https://playground.babylonjs.com/textures/heightMap.png\",\n            {\n                width: size,\n                height: size,\n                subdivisions: 128,\n                maxHeight: size / 5,\n                onReady: () => ground!.updateCoordinateHeights(),\n            },\n            scene\n        );\n\n        const mat = new BABYLON.PBRMaterial(\"mat\", scene);\n\n        mat.metallicTexture = new BABYLON.Texture(rockRoughness, scene);\n        mat.albedoTexture = new BABYLON.Texture(rockBaseColor, scene);\n        mat.bumpTexture = new BABYLON.Texture(rockNormal, scene);\n        mat.useRoughnessFromMetallicTextureGreen = true;\n        mat.metallic = 0;\n        mat.roughness = 1;\n\n        ground.material = mat;\n\n        shape.params.push(ground);\n\n        return Promise.resolve(ground);\n    }\n\n    protected static _ParseSDFData(textData: string): SDFArray {\n        const lines = textData.replace(\"\\r\", \"\").split(\"\\n\");\n\n        const dimLine = lines[0].split(\" \");\n\n        const dimX = parseFloat(dimLine[0]);\n        const dimY = parseFloat(dimLine[1]);\n        const dimZ = parseFloat(dimLine[2]);\n\n        const originLine = lines[1].split(\" \");\n\n        const origin = new BABYLON.Vector3(\n            parseFloat(originLine[0]),\n            parseFloat(originLine[1]),\n            parseFloat(originLine[2])\n        );\n\n        const step = parseFloat(lines[2]);\n\n        const data: number[] = [];\n\n        for (let i = 3; i < lines.length; ++i) {\n            const val = lines[i];\n            if (val.length === 0) {\n                continue;\n            }\n            data.push(parseFloat(val));\n        }\n\n        return {\n            dimX,\n            dimY,\n            dimZ,\n            origin,\n            step,\n            data,\n        };\n    }\n\n    public static CreateMesh(\n        scene: BABYLON.Scene,\n        shape: ICollisionShape,\n        meshFilename: string,\n        sdfFilename: string,\n        createNormals: boolean\n    ): Promise<BABYLON.Mesh> {\n        return new Promise((resolve) => {\n            const promises = [\n                BABYLON.SceneLoader.ImportMeshAsync(\n                    \"\",\n                    \"/assets/scenes/\",\n                    meshFilename,\n                    scene\n                ),\n                new Promise((resolve) => {\n                    fetch(\"/assets/sdf/\" + sdfFilename).then((response) => {\n                        response.text().then((text) => {\n                            shape.params.push(SDFHelper._ParseSDFData(text));\n                            resolve(void 0);\n                        });\n                    });\n                }),\n            ];\n\n            Promise.all(promises).then((results) => {\n                const meshes = results[0] as BABYLON.ISceneLoaderAsyncResult;\n                const mesh = meshes.meshes[0] as BABYLON.Mesh;\n                if (!mesh.material) {\n                    const material = new BABYLON.PBRMaterial(\"meshMat\", scene);\n\n                    material.metallic = 1;\n                    material.roughness = 0.05;\n                    material.albedoTexture = new BABYLON.Texture(\n                        rockBaseColor,\n                        scene\n                    );\n                    material.cullBackFaces = true;\n\n                    mesh.material = material;\n                }\n                if (createNormals) {\n                    mesh.createNormals(false);\n                }\n                mesh.scaling.setAll(shape.scale);\n                resolve(mesh);\n            });\n        });\n    }\n\n    // SD functions from https://iquilezles.org/articles/distfunctions/\n    public static SDBox(p: BABYLON.Vector3, b: BABYLON.Vector3) {\n        const q = BABYLON.TmpVectors.Vector3[0];\n        q.copyFromFloats(Math.abs(p.x), Math.abs(p.y), Math.abs(p.z));\n        q.subtractInPlace(b);\n\n        const tmp = Math.min(Math.max(q.x, q.y, q.z), 0);\n\n        q.maximizeInPlaceFromFloats(0, 0, 0);\n\n        return q.length() + tmp;\n    }\n\n    public static SDSphere(p: BABYLON.Vector3, s: number) {\n        return p.length() - s;\n    }\n\n    public static SDPlane(p: BABYLON.Vector3, n: BABYLON.Vector3, h: number) {\n        return BABYLON.Vector3.Dot(p, n) + h;\n    }\n\n    public static SDCutHollowSphere(\n        p: BABYLON.Vector3,\n        r: number,\n        h: number,\n        t: number\n    ) {\n        // sampling independent computations (only depend on shape)\n        const w = Math.sqrt(r * r - h * h);\n\n        // sampling dependant computations\n        const qx = Math.sqrt(p.x * p.x + p.z * p.z);\n        const qy = p.y;\n\n        if (h * qx < w * qy) {\n            return Math.sqrt((qx - w) * (qx - w) + (qy - h) * (qy - h));\n        }\n\n        return Math.abs(Math.sqrt(qx * qx + qy * qy) - r) - t;\n    }\n\n    public static SDVerticalCylinder(p: BABYLON.Vector3, r: number, h: number) {\n        const dx = Math.abs(Math.sqrt(p.x * p.x + p.z * p.z)) - r;\n        const dy = Math.abs(p.y) - h;\n        const dx2 = Math.max(dx, 0);\n        const dy2 = Math.max(dy, 0);\n\n        return (\n            Math.min(Math.max(dx, dy), 0.0) + Math.sqrt(dx2 * dx2 + dy2 * dy2)\n        );\n    }\n\n    public static SDTerrain(\n        p: BABYLON.Vector3,\n        size: number,\n        terrain: BABYLON.GroundMesh\n    ) {\n        return p.y - terrain.getHeightAtCoordinates(p.x, p.z);\n    }\n\n    public static SDMesh(\n        p: BABYLON.Vector3,\n        meshFilename: string,\n        sdfFilename: string,\n        createNormals: boolean,\n        sdf: SDFArray\n    ) {\n        const x = (p.x - sdf.origin.x) / sdf.step;\n        const y = (p.y - sdf.origin.y) / sdf.step;\n        const z = (p.z - sdf.origin.z) / sdf.step;\n\n        let gx = Math.floor(x);\n        let gy = Math.floor(y);\n        let gz = Math.floor(z);\n\n        gx = Math.max(Math.min(gx, sdf.dimX - 2), 0);\n        gy = Math.max(Math.min(gy, sdf.dimY - 2), 0);\n        gz = Math.max(Math.min(gz, sdf.dimZ - 2), 0);\n\n        // trilinear filtering\n        const fx = x - gx;\n        const fy = y - gy;\n        const fz = z - gz;\n\n        const a00 = sdf.data[gz * sdf.dimY * sdf.dimX + gy * sdf.dimX + gx];\n        const a10 = sdf.data[gz * sdf.dimY * sdf.dimX + gy * sdf.dimX + gx + 1];\n        const a11 =\n            sdf.data[gz * sdf.dimY * sdf.dimX + (gy + 1) * sdf.dimX + gx + 1];\n        const a01 =\n            sdf.data[gz * sdf.dimY * sdf.dimX + (gy + 1) * sdf.dimX + gx];\n\n        const a0 = a00 * (1 - fx) + a10 * fx;\n        const a1 = a01 * (1 - fx) + a11 * fx;\n        const a = a0 * (1 - fy) + a1 * fy;\n\n        const b00 =\n            sdf.data[(gz + 1) * sdf.dimY * sdf.dimX + gy * sdf.dimX + gx];\n        const b10 =\n            sdf.data[(gz + 1) * sdf.dimY * sdf.dimX + gy * sdf.dimX + gx + 1];\n        const b11 =\n            sdf.data[\n                (gz + 1) * sdf.dimY * sdf.dimX + (gy + 1) * sdf.dimX + gx + 1\n            ];\n        const b01 =\n            sdf.data[(gz + 1) * sdf.dimY * sdf.dimX + (gy + 1) * sdf.dimX + gx];\n\n        const b0 = b00 * (1 - fx) + b10 * fx;\n        const b1 = b01 * (1 - fx) + b11 * fx;\n        const b = b0 * (1 - fy) + b1 * fy;\n\n        const d = a * (1 - fz) + b * fz;\n        //const d = sdf.data[gz * sdf.dimY * sdf.dimX + gy * sdf.dimX + gx];\n\n        return d;\n    }\n\n    // normal computed with the Tetrahedron technique, see https://iquilezles.org/articles/normalsSDF/\n    public static ComputeSDFNormal(\n        pos: BABYLON.Vector3,\n        shape: ICollisionShape,\n        normal: BABYLON.Vector3\n    ) {\n        const posTemp = BABYLON.TmpVectors.Vector3[5];\n        const dir = BABYLON.TmpVectors.Vector3[6];\n\n        normal.copyFromFloats(0, 0, 0);\n\n        posTemp.copyFrom(pos);\n        dir.copyFrom(dir1);\n        normal.addInPlace(\n            dir.scaleInPlace(\n                shape.sdEvaluate(posTemp.addInPlace(eps1), ...shape.params)\n            )\n        );\n\n        posTemp.copyFrom(pos);\n        dir.copyFrom(dir2);\n        normal.addInPlace(\n            dir.scaleInPlace(\n                shape.sdEvaluate(posTemp.addInPlace(eps2), ...shape.params)\n            )\n        );\n\n        posTemp.copyFrom(pos);\n        dir.copyFrom(dir3);\n        normal.addInPlace(\n            dir.scaleInPlace(\n                shape.sdEvaluate(posTemp.addInPlace(eps3), ...shape.params)\n            )\n        );\n\n        posTemp.copyFrom(pos);\n        dir.copyFrom(dir4);\n        normal.addInPlace(\n            dir.scaleInPlace(\n                shape.sdEvaluate(posTemp.addInPlace(eps4), ...shape.params)\n            )\n        );\n\n        BABYLON.Vector3.TransformNormalToRef(normal, shape.transf, normal);\n\n        normal.normalize();\n    }\n\n    public static ComputeTerrainNormal(\n        pos: BABYLON.Vector3,\n        shape: ICollisionShape,\n        normal: BABYLON.Vector3\n    ) {\n        const terrain = shape.params[1] as BABYLON.GroundMesh;\n\n        terrain.getNormalAtCoordinatesToRef(pos.x, pos.z, normal);\n    }\n}\n"],"names":["eps","eps1","eps2","eps3","eps4","dir1","dir2","dir3","dir4","SDFHelper","static","scene","shape","extents","box","width","x","height","y","depth","z","material","metallic","roughness","albedoTexture","cullBackFaces","Promise","resolve","s","sphere","diameter","segments","radius","planeDist","thickness","plane","size","rotation","Math","PI","position","csg1","csgp","dispose","subtractInPlace","mesh","toMesh","computeWorldMatrix","refreshBoundingInfo","scaling","setAll","getBoundingInfo","boundingBox","maximumWorld","csg2","meshFinal","bakeCurrentTransformIntoVertices","r","h","cylinder","tessellation","ground","subdivisions","maxHeight","onReady","updateCoordinateHeights","mat","metallicTexture","bumpTexture","useRoughnessFromMetallicTextureGreen","params","push","textData","lines","replace","split","dimLine","dimX","parseFloat","dimY","dimZ","originLine","origin","step","data","i","length","val","meshFilename","sdfFilename","createNormals","promises","fetch","then","response","text","_ParseSDFData","all","results","meshes","scale","p","b","q","copyFromFloats","abs","tmp","min","max","maximizeInPlaceFromFloats","n","t","w","sqrt","qx","qy","dx","dy","dx2","dy2","terrain","getHeightAtCoordinates","sdf","gx","floor","gy","gz","fx","fy","fz","a00","a10","a11","a","b00","b10","b11","pos","normal","posTemp","dir","copyFrom","addInPlace","scaleInPlace","sdEvaluate","transf","normalize","getNormalAtCoordinatesToRef"],"sourceRoot":""}