{"version":3,"file":"365.b5e72f607733d6cfc9df.js","mappings":"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","sources":["webpack://babylonjs-fluid-rendering/./src/assets/scenes/scene_b.glb","webpack://babylonjs-fluid-rendering/./src/scenes/fluidSimulationDemoBoxSphere.ts"],"sourcesContent":["export default __webpack_public_path__ + \"0a2646c918e59d9f9f90ca76255aa40f.glb\";","import * as BABYLON from \"@babylonjs/core\";\n\nimport * as LiLGUI from \"lil-gui\";\n\nimport { FluidSimulationDemoBase } from \"./fluidSimulationDemoBase\";\nimport { ICollisionShape } from \"./Utils/sdfHelper\";\nimport myBox from \"../assets/scenes/scene_b.glb\";\nexport class FluidSimulationDemoBoxSphere extends FluidSimulationDemoBase {\n    private _checkXZBounds: boolean;\n    private _sphereMesh: BABYLON.Nullable<BABYLON.Mesh> = null;\n    private _boxMin: BABYLON.Vector3;\n    private _boxMax: BABYLON.Vector3;\n    private _boxMesh: BABYLON.Nullable<BABYLON.Mesh>;\n    private _boxMaterial: BABYLON.Nullable<BABYLON.PBRMaterial>;\n    private _boxMeshFront: BABYLON.Nullable<BABYLON.Mesh>;\n    private _boxMaterialFront: BABYLON.Nullable<BABYLON.PBRMaterial>;\n    private _origCollisionPlanes: Array<BABYLON.Plane>;\n    private _collisionPlanes: Array<\n        [BABYLON.Nullable<BABYLON.Mesh>, ICollisionShape]\n    >;\n    private _angleX: number;\n    private _angleY: number;\n    private _prevTransfo: BABYLON.Matrix;\n    private _autoRotateBox: boolean;\n    private _wallMesh: BABYLON.Nullable<BABYLON.Mesh> = null;\n    private _wallMesh1: BABYLON.Nullable<BABYLON.Mesh> = null;\n    private _wallMesh2: BABYLON.Nullable<BABYLON.Mesh> = null;\n    private _wallMesh3: BABYLON.Nullable<BABYLON.Mesh> = null;\n    // private _passPP: BABYLON.PostProcess;\n    private defaultPPLine: BABYLON.Nullable<BABYLON.DefaultRenderingPipeline> = null;\n    private _sceneRenderObserver: BABYLON.Nullable<\n        BABYLON.Observer<BABYLON.Scene>\n    >;\n    private _sceneAfterCameraRenderObserver: BABYLON.Nullable<\n        BABYLON.Observer<BABYLON.Camera>\n    >;\n    private _sceneKeyboardObserver: BABYLON.Nullable<\n        BABYLON.Observer<BABYLON.KeyboardInfo>\n    >;\n    private _onEngineResizeObserver: BABYLON.Nullable<\n        BABYLON.Observer<BABYLON.Engine>\n    >;\n    private _customRootMesh :BABYLON.Nullable<BABYLON.Mesh> = null;\n    private _globalScale = 0.5;\n    private _collisionBoxEnabled = false;\n\n    constructor(scene: BABYLON.Scene) {\n        super(scene);\n\n        const halfSize = 0.35 * this._globalScale;\n        this._boxMin = new BABYLON.Vector3(-halfSize, -halfSize, -halfSize);\n        this._boxMax = new BABYLON.Vector3(halfSize, halfSize, halfSize);\n        this._boxMesh = null;\n        this._boxMaterial = null;\n        this._boxMeshFront = null;\n        this._boxMaterialFront = null;\n\n        this._checkXZBounds = true;\n        this._origCollisionPlanes = [\n            new BABYLON.Plane(0, 0, -1, Math.abs(this._boxMax.z)),\n            new BABYLON.Plane(0, 0, 1, Math.abs(this._boxMin.z)),\n            new BABYLON.Plane(1, 0, 0, Math.abs(this._boxMin.x)),\n            new BABYLON.Plane(-1, 0, 0, Math.abs(this._boxMax.x)),\n            new BABYLON.Plane(0, -1, 0, Math.abs(this._boxMax.y)),\n            new BABYLON.Plane(0, 1, 0, Math.abs(this._boxMin.y)),\n            new BABYLON.Plane(0, 1, 0, Math.abs(this._boxMin.y)),\n        ];\n        this._collisionPlanes = [];\n        for (let i = 0; i < this._origCollisionPlanes.length; ++i) {\n            const plane = this._origCollisionPlanes[i];\n            this.addCollisionPlane(\n                plane.normal,\n                plane.d,\n                i === this._origCollisionPlanes.length - 1 ? 0.98 : undefined\n            );\n        }\n\n        this._angleX = 0;\n        this._angleY = 0;\n        this._prevTransfo = BABYLON.Matrix.Identity();\n        this._autoRotateBox = false;\n\n        this._sceneRenderObserver = null;\n        this._sceneAfterCameraRenderObserver = null;\n        this._sceneKeyboardObserver = null;\n        this._onEngineResizeObserver = null;\n\n        // this._passPP = new BABYLON.PassPostProcess(\n        //     \"pass\",\n        //     1,\n        //     null,\n        //     undefined,\n        //     this._engine\n        // );\n        // this._passPP.externalTextureSamplerBinding = true;\n\n        // const sphereRadius = 0.16;\n\n        // this._sphereMesh = null;\n        // this.addCollisionSphere(\n        //     new BABYLON.Vector3(\n        //         (this._boxMin.x + this._boxMax.x) / 2,\n        //         this._boxMin.y + sphereRadius,\n        //         (this._boxMin.z + this._boxMax.z) / 2 - 0.1\n        //     ),\n        //     sphereRadius\n        // );\n\n        this._wallMesh = null;\n        this._wallMesh1 = null;\n        this._wallMesh2 = null;\n        this._wallMesh3 = null;\n        if (this._collisionBoxEnabled) {\n            this.addCollisionBox(\n                new BABYLON.Vector3(0.025, 0.0, 0.0),\n                new BABYLON.Vector3((90 * Math.PI) / 180, 0, 0),\n                new BABYLON.Vector3(0.1, 0.005, 0.1),\n            );\n            this.addCollisionBox(\n                new BABYLON.Vector3(0.025, 0.0, 0.035),\n                new BABYLON.Vector3((90 * Math.PI) / 180, 0, 0),\n                new BABYLON.Vector3(0.1, 0.005, 0.1),\n            );\n            this.addCollisionBox(\n                new BABYLON.Vector3(0.025, 0.0, -0.035),\n                new BABYLON.Vector3((90 * Math.PI) / 180, 0, 0),\n                new BABYLON.Vector3(0.1, 0.005, 0.1),\n            );\n    \n            this.addCollisionBox(\n                new BABYLON.Vector3(0.025, 0.0, -0.07),\n                new BABYLON.Vector3((90 * Math.PI) / 180, 0, 0),\n                new BABYLON.Vector3(0.1, 0.005, 0.1),\n            );\n        }\n\n        this.loadCustomModel();\n        this._setCustomDebugLayer();\n        this._initMyPostProcessPipeline();\n    }\n\n    private _initMyPostProcessPipeline() {\n        this.defaultPPLine = new BABYLON.DefaultRenderingPipeline(\n            \"defaultPipeline\", // The name of the pipeline\n            true, // Do you want the pipeline to use HDR texture?\n            this._scene, // The scene instance\n            [this._scene.activeCamera!] // The list of cameras to be attached to\n        );\n        this.defaultPPLine.samples = 1;\n        this.defaultPPLine.depthOfFieldEnabled = true;\n        this.defaultPPLine.depthOfField.focalLength = 246.4;\n        this.defaultPPLine.depthOfField.fStop = 32;\n        this.defaultPPLine.depthOfField.focusDistance = 1000;\n        this.defaultPPLine.depthOfField.lensSize = 6;\n\n        this.defaultPPLine.fxaaEnabled = true;\n        // defaultPPLine.fxaa.samples = 4;\n        this.defaultPPLine.imageProcessingEnabled = true;\n        this.defaultPPLine.imageProcessing.contrast = 1.8;\n        this.defaultPPLine.imageProcessing.exposure = 2.2;\n        this.defaultPPLine.imageProcessing.toneMappingEnabled = false;\n        this.defaultPPLine.imageProcessing.toneMappingType = BABYLON.ImageProcessingConfiguration.TONEMAPPING_ACES;\n        this.defaultPPLine.glowLayerEnabled = true;\n        if (this.defaultPPLine.glowLayer) {\n            this.defaultPPLine.glowLayer.blurKernelSize = 16;\n            this.defaultPPLine.glowLayer.intensity = 1.0;\n        }\n        // defaultPPLine.grainEnabled = true;\n        // defaultPPLine.grain.animated = true;\n        // defaultPPLine.grain.intensity = 8.2;\n        this.defaultPPLine.bloomEnabled = true;\n    }\n\n    _setCustomDebugLayer() {\n        type di = {\n            [key: string]: boolean\n          }\n          const debugKeyInfo: di = {\n            'Shift': false,\n            'D': false\n          }\n          this._scene.onKeyboardObservable.add((kbInfo) => {\n            switch (kbInfo.type) {\n              case BABYLON.KeyboardEventTypes.KEYDOWN:\n                debugKeyInfo[kbInfo.event.key] = true\n                break;\n              case BABYLON.KeyboardEventTypes.KEYUP:\n                debugKeyInfo[kbInfo.event.key] = false\n                break;\n            }\n            if (debugKeyInfo['Shift'] && debugKeyInfo['D']) {\n              this._scene.debugLayer.isVisible() ? this._scene.debugLayer.hide() : this._scene.debugLayer.show({\n                overlay: true\n              })\n            }\n          });\n    }\n\n    loadCustomModel() {\n        BABYLON.SceneLoader.AppendAsync(\"\", myBox, this._scene).then((importResult) => {\n            this._customRootMesh = importResult.getMeshByName(\"__root__\") as BABYLON.Mesh;\n            const scaleMesh = 0.1 * this._globalScale;\n            this._customRootMesh?.scaling.set(scaleMesh,scaleMesh,scaleMesh)\n      \n            const lightConfig = [\n              {\n                intensity: 0,\n                diffuseColor: BABYLON.Color3.FromInts(0.686 * 255, 255, 0.275 * 255),\n                specularColor: BABYLON.Color3.FromInts(0, 0.871 * 255, 255),\n                position: new BABYLON.Vector3(0, 0, -6.294),\n              },\n              {\n                intensity: 0,\n                diffuseColor: BABYLON.Color3.FromInts(0, 0.863 * 255, 255),\n                specularColor: BABYLON.Color3.FromInts(0, 255, 0.678 * 255),\n                position: new BABYLON.Vector3(0.178, -0.037, 6.285),\n              }\n            ]\n            let lightNode: BABYLON.TransformNode|undefined = undefined;\n            importResult.lights.forEach((light, index) => {\n              const pLight = light as BABYLON.PointLight;\n              if (lightNode === undefined) {\n                lightNode = pLight.parent as BABYLON.TransformNode;\n                lightNode.position.set(0, 0, 0);\n              }\n              lightNode.position.set(0,0,0);\n              pLight.parent = lightNode;\n              pLight.position.copyFrom(lightConfig[index].position);\n              pLight.intensity = lightConfig[index].intensity;\n              pLight.diffuse.copyFrom(lightConfig[index].diffuseColor);\n              pLight.specular.copyFrom(lightConfig[index].specularColor);\n            })\n      \n            this._scene.registerBeforeRender(() => {\n              if (lightNode !== undefined) {\n                lightNode.rotationQuaternion = null\n                lightNode.rotation.y = ((this._scene.activeCameras?.[0] ?? this._scene.activeCamera) as any)!.alpha + Math.PI;\n              }\n            });\n      \n            importResult.meshes.forEach((mesh)=> {\n              if (mesh && mesh.name && mesh.material) {\n            //   (mesh.material as BABYLON.PBRMaterial).maxSimultaneousLights = 8\n              switch (mesh.name) {\n                case \"立方体.006_Baked\":\n                  mesh.material.alpha = 0.4\n                  mesh.alphaIndex = 4;\n                  mesh.material.transparencyMode = BABYLON.Material.MATERIAL_ALPHABLEND\n                  mesh.material.alphaMode = BABYLON.Engine.ALPHA_COMBINE;\n                  // eslint-disable-next-line no-case-declarations\n                  const boxMat: BABYLON.PBRMaterial = (mesh.material as BABYLON.PBRMaterial);\n                  boxMat.metallic = 1;\n                  boxMat.roughness = 0.2;\n                  boxMat.albedoColor.r = 0.50;\n                  boxMat.albedoColor.g = 0.04;\n                  boxMat.albedoColor.b = 1.0;\n                  boxMat.metallicReflectanceColor.r = 0.97;\n                  boxMat.metallicReflectanceColor.g = 0.029;\n                  boxMat.metallicReflectanceColor.b = 1.0;\n                  boxMat.anisotropy.isEnabled = true;\n                  boxMat.anisotropy.intensity = 0.8;\n                  boxMat.sheen.isEnabled = true;\n                  boxMat.sheen.intensity = 1.0;\n                  boxMat.sheen.color.r = 0.816;\n                  boxMat.sheen.color.g = 0.006;\n                  boxMat.sheen.color.b = 1.0;\n                  boxMat.sheen.useRoughnessFromMainTexture = true;\n                  boxMat.subSurface.tintColor.r = 0.541;\n                  boxMat.subSurface.tintColor.g = 0.933;\n                  boxMat.subSurface.tintColor.b = 1.0;\n                  boxMat.subSurface.isScatteringEnabled = true;\n                  boxMat.subSurface.isTranslucencyEnabled = true;\n                  boxMat.disableDepthWrite = true\n                  break;\n                case \"布尔\":\n                case \"柱体.001_Baked\":\n                case \"平面_primitive0\":\n                case \"平面_primitive1\":\n                // case \"边线_Baked\":\n                  mesh.visibility = 0\n                  break;\n                case \"立方体.011_Baked\":\n                  mesh.alphaIndex = 3\n                  // mesh.material.disableDepthWrite = true;\n                  mesh.material.alpha = 0.6\n                  mesh.material.transparencyMode = BABYLON.Material.MATERIAL_ALPHABLEND;\n                  mesh.material.alphaMode = BABYLON.Engine.ALPHA_COMBINE;\n                  // (mesh.material as PBRMaterial).emissiveColor = Color3.FromInts(0.141,0, 0.482);\n                  (mesh.material as BABYLON.PBRMaterial).emissiveColor = BABYLON.Color3.FromInts(3.4,0, 51);\n                  (mesh.material as BABYLON.PBRMaterial).metallic = 1.0;\n                  (mesh.material as BABYLON.PBRMaterial).roughness = 0.0;\n                  break;\n                case \"立方体.013_Baked\":\n                  mesh.alphaIndex = 3\n                  // mesh.material.disableDepthWrite = true;\n                  mesh.material.alpha = 0.4\n                  mesh.material.transparencyMode = BABYLON.Material.MATERIAL_ALPHABLEND;\n                  mesh.material.alphaMode = BABYLON.Engine.ALPHA_COMBINE;\n                  (mesh.material as BABYLON.PBRMaterial).emissiveColor = BABYLON.Color3.FromInts(12.6,0, 148);\n                  (mesh.material as BABYLON.PBRMaterial).metallic = 0.93;\n                  (mesh.material as BABYLON.PBRMaterial).roughness = 0.0;\n                  break;\n                case \"立方体.012_Baked\":\n                case \"立方体.014_Baked\":\n                  mesh.alphaIndex = 3\n                  mesh.material.alpha = 0.26\n                  mesh.material.transparencyMode = BABYLON.Material.MATERIAL_ALPHABLEND\n                  mesh.material.alphaMode = BABYLON.Engine.ALPHA_ADD;\n                  (mesh.material as BABYLON.PBRMaterial).emissiveColor = BABYLON.Color3.FromInts(0.059,0.161, 1.0);\n                  (mesh.material as BABYLON.PBRMaterial).metallic = 1.0;\n                  (mesh.material as BABYLON.PBRMaterial).roughness = 0.15;\n                  break;\n                case \"Cylinder\":\n                  break;\n                default:\n                  break;\n              }\n              }\n            })\n          })\n    }\n\n    protected async _run() {\n        // Get collision meshes\n        for (let i = 0; i < this._origCollisionPlanes.length; ++i) {\n            this._collisionPlanes.push(this._collisionObjects[i]);\n        }\n\n        this._collisionPlanes[this._collisionPlanes.length - 1][1].disabled = true;\n\n        if (this._collisionBoxEnabled) {\n            this._wallMesh = this._collisionObjects[this._origCollisionPlanes.length][0];\n            this._wallMesh1 = this._collisionObjects[this._origCollisionPlanes.length + 1][0];\n            this._wallMesh2 = this._collisionObjects[this._origCollisionPlanes.length + 2][0];\n            this._wallMesh3 = this._collisionObjects[this._origCollisionPlanes.length + 3][0];\n        }\n        if (this._wallMesh && this._wallMesh.material) {\n            this._wallMesh.material.alpha = 0.0;\n        }\n        if (this._wallMesh1 && this._wallMesh1.material) {\n            this._wallMesh1.material.alpha = 0.0;\n        }\n        if (this._wallMesh2 && this._wallMesh2.material) {\n            this._wallMesh2.material.alpha = 0.0;\n        }\n        if (this._wallMesh3 && this._wallMesh3.material) {\n            this._wallMesh3.material.alpha = 0.0;\n        }\n        \n\n        // Reset camera\n        const camera = this._scene.activeCameras?.[0] ?? this._scene.activeCamera;\n        \n        const tempScene = new BABYLON.Scene(this._scene.getEngine());\n        const tempCamera = new BABYLON.ArcRotateCamera(\"camera\", 14.33, 1.594, this._globalScale, BABYLON.Vector3.Zero(), tempScene);\n        tempCamera.lowerRadiusLimit = this._globalScale;\n        tempCamera.upperRadiusLimit = this._globalScale;\n        tempCamera.useAutoRotationBehavior = true;\n        tempCamera.attachControl(document.getElementById(\"renderCanvas\"), true);\n        tempScene.attachControl(true,true,true);\n        tempScene.clearColor = new BABYLON.Color4(0, 0, 0, 0);\n        tempScene.autoClear = false\n\n        this._scene.onAfterCameraRenderObservable.add(() => {\n            tempScene.render()\n            if (this._customRootMesh) {\n                this._customRootMesh.rotationQuaternion = tempCamera.absoluteRotation;\n                this._rotateMeshes(-tempCamera.alpha, -tempCamera.beta);\n            }\n        })\n\n        if (camera) {\n            (camera as BABYLON.ArcRotateCamera).alpha = 1;\n            (camera as BABYLON.ArcRotateCamera).beta = 1.1;\n            (camera as BABYLON.ArcRotateCamera).radius = 1.9;\n            (camera as BABYLON.ArcRotateCamera).panningSensibility = 0;\n            (camera as BABYLON.ArcRotateCamera).lowerAlphaLimit = 1;\n            (camera as BABYLON.ArcRotateCamera).upperAlphaLimit = 1;\n            (camera as BABYLON.ArcRotateCamera).lowerBetaLimit = 1.1;\n            (camera as BABYLON.ArcRotateCamera).upperBetaLimit = 1.1;\n            (camera as BABYLON.ArcRotateCamera).lowerRadiusLimit = 1.9 * this._globalScale;\n            (camera as BABYLON.ArcRotateCamera).upperRadiusLimit = 1.9 * this._globalScale;\n\n            // camera.outputRenderTarget = new BABYLON.RenderTargetTexture(\n            //     \"rttFinal\",\n            //     {\n            //         width: this._engine.getRenderWidth(),\n            //         height: this._engine.getRenderHeight(),\n            //     },\n            //     this._scene\n            // );\n        }\n\n        // Simulation parameters\n        this._fluidRenderObject.object.particleSize = 0.03;\n        this._fluidRenderObject.object.particleThicknessAlpha = 0.017;\n\n        this._fluidSim!.smoothingRadius = 0.04;\n        this._particleGenerator!.particleRadius = 0.02;\n        this._fluidSim!.densityReference = 10000;\n        this._fluidSim!.pressureConstant = 0.4;\n        this._fluidSim!.viscosity = 0.002;\n        this._fluidSim!.maxVelocity = 6;\n        this._fluidSim!.maxAcceleration = 10000;\n\n        // Create materials\n        // this._boxMaterial = new BABYLON.PBRMaterial(\"BoxMeshMat\", this._scene);\n        // this._boxMaterial.metallic = 0.3;\n        // this._boxMaterial.roughness = 0;\n        // this._boxMaterial.alpha = 0.0;\n        // this._boxMaterial.backFaceCulling = true;\n        // this._boxMaterial.cullBackFaces = false;\n\n        // this._boxMaterialFront = this._boxMaterial.clone(\"BoxMeshFrontMat\");\n        // this._boxMaterialFront.cullBackFaces = true;\n\n        // Create meshes\n        // this._boxMesh = BABYLON.MeshBuilder.CreateBox(\n        //     \"boxMesh\",\n        //     {\n        //         width: this._boxMax.x - this._boxMin.x,\n        //         height: this._boxMax.y - this._boxMin.y,\n        //         depth: this._boxMax.z - this._boxMin.z,\n        //     },\n        //     this._scene\n        // );\n        // this._boxMesh.material = this._boxMaterial;\n        // this._boxMesh.position.x = (this._boxMin.x + this._boxMax.x) / 2;\n        // this._boxMesh.position.y = (this._boxMin.y + this._boxMax.y) / 2;\n        // this._boxMesh.position.z = (this._boxMin.z + this._boxMax.z) / 2;\n        // this._boxMesh.isPickable = false;\n        //\n        // this._boxMeshFront = this._boxMesh.clone(\"boxMeshFront\");\n        // this._boxMeshFront.material = this._boxMaterialFront;\n        // this._boxMeshFront.layerMask = 0x10000000; // make sure the mesh is not displayed by the camera - we will display it ourselves by a direct call to render()\n\n        // Render the front side of the box\n        // this._passPP.onApplyObservable.add((effect) => {\n        //     effect.setTexture(\"textureSampler\", camera!.outputRenderTarget);\n        // });\n\n        // let depthIsShared = false;\n        // this._sceneAfterCameraRenderObserver =\n        //     this._scene.onAfterCameraRenderObservable.add(() => {\n        //         const firstPP = camera?._getFirstPostProcess();\n        //         if (\n        //             firstPP &&\n        //             firstPP.inputTexture.depthStencilTexture &&\n        //             !depthIsShared\n        //         ) {\n        //             firstPP.inputTexture._shareDepth(\n        //                 camera!.outputRenderTarget!.renderTarget!\n        //             );\n        //             depthIsShared = true;\n        //         }\n        //         if (depthIsShared) {\n        //             this._boxMeshFront?.render(\n        //                 this._boxMeshFront.subMeshes[0],\n        //                 true\n        //             );\n        //             this._scene.postProcessManager.directRender(\n        //                 [this._passPP!],\n        //                 null\n        //             );\n        //         }\n        //     });\n\n        this._onEngineResizeObserver = this._engine.onResizeObservable.add(\n            () => {\n                camera?.outputRenderTarget?.resize({\n                    width: this._engine.getRenderWidth(true),\n                    height: this._engine.getRenderHeight(true),\n                });\n                // depthIsShared = false;\n            }\n        );\n\n        // Move meshes\n        // this._sceneRenderObserver = this._scene.onBeforeRenderObservable.add(\n        //     () => {\n        //         if (arrowLeftDown) {\n        //             this._angleX += (2 * 30) / 60;\n        //             this._rotateMeshes(this._angleX, this._angleY);\n        //         }\n        //         if (arrowRightDown) {\n        //             this._angleX -= (2 * 30) / 60;\n        //             this._rotateMeshes(this._angleX, this._angleY);\n        //         }\n        //         if (arrowUpDown) {\n        //             this._angleY -= (2 * 30) / 60;\n        //             this._rotateMeshes(this._angleX, this._angleY);\n        //         }\n        //         if (arrowDownDown) {\n        //             this._angleY += (2 * 30) / 60;\n        //             this._rotateMeshes(this._angleX, this._angleY);\n        //         }\n        //\n        //         if (this._autoRotateBox) {\n        //             const fps = this._engine.getFps();\n        //             this._angleX += 20 / fps;\n        //             this._angleY += 30 / fps;\n        //             this._rotateMeshes(this._angleX, this._angleY);\n        //         }\n        //     }\n        // );\n\n        super._run().then(() => {\n            setTimeout(() => {\n                // this._fluidSim!.smoothingRadius = 0.0;\n                document.getElementById(\"renderCanvas\")!.style.opacity = \"1.0\";\n            }, 2900)\n        });\n    }\n\n    public dispose(): void {\n        super.dispose();\n\n        const camera =\n            this._scene.activeCameras?.[0] ?? this._scene.activeCamera;\n\n        if (camera) {\n            camera.outputRenderTarget?.dispose();\n            camera.outputRenderTarget = null;\n        }\n\n        this._scene.onBeforeRenderObservable.remove(this._sceneRenderObserver);\n        this._scene.onAfterCameraRenderObservable.remove(\n            this._sceneAfterCameraRenderObserver\n        );\n        this._scene.onKeyboardObservable.remove(this._sceneKeyboardObserver);\n\n        // this._passPP.dispose();\n        this.defaultPPLine?.dispose();\n        this._boxMesh?.dispose();\n        this._boxMeshFront?.dispose();\n        this._boxMaterial?.dispose();\n        this._engine.onResizeObservable.remove(this._onEngineResizeObserver);\n    }\n\n    protected _makeGUIMainMenu(): void {\n        const params = {\n            checkXZBounds: true,\n            autoRotateBox: false,\n            restart: () => {\n                this._angleX = this._angleY = 0;\n                this._autoRotateBox = false;\n                autoRotateBoxCtrl?.setValue(false);\n                this._rotateMeshes(0, 0);\n                this._generateParticles();\n            },\n            // boxOpacity: this._boxMaterial!.alpha,\n        };\n\n        const mainMenu = this._gui!;\n\n        let autoRotateBoxCtrl: BABYLON.Nullable<LiLGUI.Controller> = null;\n\n        mainMenu.add(params, \"restart\").name(\"Restart\");\n\n        mainMenu\n            .add(params, \"checkXZBounds\")\n            .name(\"Check box bounds\")\n            .onChange((value: boolean) => {\n                this._checkXZBounds = value;\n                this._boxMesh?.setEnabled(value);\n                this._boxMeshFront?.setEnabled(value);\n                for (let i = 0; i < this._collisionPlanes.length; ++i) {\n                    this._collisionPlanes[i][1].disabled =\n                        (!value && i < this._collisionPlanes.length - 1) ||\n                        (value && i === this._collisionPlanes.length - 1);\n                }\n                if (!value) {\n                    this._autoRotateBox = false;\n                    autoRotateBoxCtrl?.setValue(false);\n                }\n            });\n\n        autoRotateBoxCtrl = mainMenu\n            .add(params, \"autoRotateBox\")\n            .name(\"Auto rotate box\")\n            .onChange((value: boolean) => {\n                this._autoRotateBox = value;\n            });\n\n        // mainMenu\n        //     .add(params, \"boxOpacity\", 0, 1, 0.01)\n        //     .name(\"Box opacity\")\n        //     .onChange((value: any) => {\n        //         this._boxMaterial!.alpha = value;\n        //         this._boxMaterialFront!.alpha = value;\n        //     });\n    }\n\n    protected _onPaused(value: boolean) {\n        super._onPaused(value);\n\n        if (value) {\n            this._autoRotateBox = false;\n        }\n    }\n\n    protected _rotateMeshes(angleX: number, angleY: number): void {\n        const transfo = BABYLON.Matrix.RotationYawPitchRoll(\n            angleX,\n            0,\n            angleY,\n        );\n\n        const boxVertices = [\n            new BABYLON.Vector3(this._boxMin.x, this._boxMin.y, this._boxMin.z),\n            new BABYLON.Vector3(this._boxMin.x, this._boxMax.y, this._boxMin.z),\n            new BABYLON.Vector3(this._boxMin.x, this._boxMax.y, this._boxMax.z),\n            new BABYLON.Vector3(this._boxMin.x, this._boxMin.y, this._boxMax.z),\n            new BABYLON.Vector3(this._boxMax.x, this._boxMin.y, this._boxMin.z),\n            new BABYLON.Vector3(this._boxMax.x, this._boxMax.y, this._boxMin.z),\n            new BABYLON.Vector3(this._boxMax.x, this._boxMax.y, this._boxMax.z),\n            new BABYLON.Vector3(this._boxMax.x, this._boxMin.y, this._boxMax.z),\n        ];\n\n        let ymin = 1e10;\n        for (let i = 0; i < boxVertices.length; ++i) {\n            const v = BABYLON.Vector3.TransformCoordinates(\n                boxVertices[i],\n                transfo\n            );\n            ymin = Math.min(ymin, v.y);\n        }\n\n        this._collisionPlanes[\n            this._origCollisionPlanes.length - 1\n        ][1].params[1] = Math.abs(ymin) + 0.02;\n\n        for (let i = 0; i < this._origCollisionPlanes.length - 1; ++i) {\n            const plane = this._origCollisionPlanes[i].transform(transfo);\n            this._collisionPlanes[i][1].params = [plane.normal, plane.d];\n        }\n\n        const quat = BABYLON.Quaternion.FromRotationMatrix(transfo);\n\n        this._prevTransfo.invert();\n\n        if (this._sphereMesh) {\n            const tmp = BABYLON.Vector3.TransformCoordinates(\n                this._sphereMesh.position,\n                this._prevTransfo\n            );\n\n            this._sphereMesh.rotationQuaternion = quat;\n            this._sphereMesh.position = BABYLON.Vector3.TransformCoordinates(\n                tmp,\n                transfo\n            );\n        }\n\n        if (this._wallMesh) {\n            const tmp = BABYLON.Vector3.TransformCoordinates(\n                this._wallMesh.position,\n                this._prevTransfo\n            );\n\n            const m = BABYLON.Matrix.RotationYawPitchRoll(\n                0,\n                (90 * Math.PI) / 180,\n                0\n            );\n            const t = BABYLON.Matrix.Translation(tmp.x, tmp.y, tmp.z);\n\n            m.multiplyToRef(t, m).multiplyToRef(transfo, m);\n            const qf =\n                this._wallMesh.rotationQuaternion ?? new BABYLON.Quaternion();\n\n            m.decompose(undefined, qf, this._wallMesh.position);\n\n            this._wallMesh.rotationQuaternion = qf;\n        }\n        \n        if (this._wallMesh1) {\n            const tmp = BABYLON.Vector3.TransformCoordinates(\n                this._wallMesh1.position,\n                this._prevTransfo\n            );\n\n            const m = BABYLON.Matrix.RotationYawPitchRoll(\n                0,\n                (90 * Math.PI) / 180,\n                0\n            );\n            const t = BABYLON.Matrix.Translation(tmp.x, tmp.y, tmp.z);\n\n            m.multiplyToRef(t, m).multiplyToRef(transfo, m);\n            const qf =\n                this._wallMesh1.rotationQuaternion ?? new BABYLON.Quaternion();\n\n            m.decompose(undefined, qf, this._wallMesh1.position);\n\n            this._wallMesh1.rotationQuaternion = qf;\n        }\n        \n        if (this._wallMesh2) {\n            const tmp = BABYLON.Vector3.TransformCoordinates(\n                this._wallMesh2.position,\n                this._prevTransfo\n            );\n\n            const m = BABYLON.Matrix.RotationYawPitchRoll(\n                0,\n                (90 * Math.PI) / 180,\n                0\n            );\n            const t = BABYLON.Matrix.Translation(tmp.x, tmp.y, tmp.z);\n\n            m.multiplyToRef(t, m).multiplyToRef(transfo, m);\n            const qf =\n                this._wallMesh2.rotationQuaternion ?? new BABYLON.Quaternion();\n\n            m.decompose(undefined, qf, this._wallMesh2.position);\n\n            this._wallMesh2.rotationQuaternion = qf;\n        }\n        if (this._wallMesh3) {\n            const tmp = BABYLON.Vector3.TransformCoordinates(\n                this._wallMesh3.position,\n                this._prevTransfo\n            );\n\n            const m = BABYLON.Matrix.RotationYawPitchRoll(\n                0,\n                (90 * Math.PI) / 180,\n                0\n            );\n            const t = BABYLON.Matrix.Translation(tmp.x, tmp.y, tmp.z);\n\n            m.multiplyToRef(t, m).multiplyToRef(transfo, m);\n            const qf =\n                this._wallMesh3.rotationQuaternion ?? new BABYLON.Quaternion();\n\n            m.decompose(undefined, qf, this._wallMesh3.position);\n\n            this._wallMesh3.rotationQuaternion = qf;\n        }\n\n        if (this._boxMesh && this._boxMeshFront) {\n            this._boxMesh.rotationQuaternion =\n                this._boxMeshFront.rotationQuaternion = quat;\n            this._boxMesh.position.x = (this._boxMin.x + this._boxMax.x) / 2;\n            this._boxMesh.position.y = (this._boxMin.y + this._boxMax.y) / 2;\n            this._boxMesh.position.z = (this._boxMin.z + this._boxMax.z) / 2;\n            this._boxMesh.position = BABYLON.Vector3.TransformCoordinates(\n                this._boxMesh.position,\n                transfo\n            );\n            this._boxMeshFront.position = this._boxMesh.position;\n        }\n\n        this._prevTransfo.copyFrom(transfo);\n    }\n}\n"],"names":["FluidSimulationDemoBoxSphere","FluidSimulationDemoBase","constructor","scene","super","_sphereMesh","_wallMesh","_wallMesh1","_wallMesh2","_wallMesh3","defaultPPLine","_customRootMesh","_globalScale","_collisionBoxEnabled","halfSize","this","_boxMin","_boxMax","_boxMesh","_boxMaterial","_boxMeshFront","_boxMaterialFront","_checkXZBounds","_origCollisionPlanes","Math","abs","z","x","y","_collisionPlanes","i","length","plane","addCollisionPlane","normal","d","undefined","_angleX","_angleY","_prevTransfo","_autoRotateBox","_sceneRenderObserver","_sceneAfterCameraRenderObserver","_sceneKeyboardObserver","_onEngineResizeObserver","addCollisionBox","PI","loadCustomModel","_setCustomDebugLayer","_initMyPostProcessPipeline","_scene","activeCamera","samples","depthOfFieldEnabled","depthOfField","focalLength","fStop","focusDistance","lensSize","fxaaEnabled","imageProcessingEnabled","imageProcessing","contrast","exposure","toneMappingEnabled","toneMappingType","glowLayerEnabled","glowLayer","blurKernelSize","intensity","bloomEnabled","debugKeyInfo","onKeyboardObservable","add","kbInfo","type","event","key","debugLayer","isVisible","hide","show","overlay","then","importResult","getMeshByName","scaleMesh","scaling","set","lightConfig","diffuseColor","specularColor","position","lightNode","lights","forEach","light","index","pLight","parent","copyFrom","diffuse","specular","registerBeforeRender","rotationQuaternion","rotation","activeCameras","alpha","meshes","mesh","name","material","alphaIndex","transparencyMode","alphaMode","boxMat","metallic","roughness","albedoColor","r","g","b","metallicReflectanceColor","anisotropy","isEnabled","sheen","color","useRoughnessFromMainTexture","subSurface","tintColor","isScatteringEnabled","isTranslucencyEnabled","disableDepthWrite","visibility","emissiveColor","async","push","_collisionObjects","disabled","camera","tempScene","getEngine","tempCamera","lowerRadiusLimit","upperRadiusLimit","useAutoRotationBehavior","attachControl","document","getElementById","clearColor","autoClear","onAfterCameraRenderObservable","render","absoluteRotation","_rotateMeshes","beta","radius","panningSensibility","lowerAlphaLimit","upperAlphaLimit","lowerBetaLimit","upperBetaLimit","_fluidRenderObject","object","particleSize","particleThicknessAlpha","_fluidSim","smoothingRadius","_particleGenerator","particleRadius","densityReference","pressureConstant","viscosity","maxVelocity","maxAcceleration","_engine","onResizeObservable","outputRenderTarget","resize","width","getRenderWidth","height","getRenderHeight","_run","setTimeout","style","opacity","dispose","onBeforeRenderObservable","remove","_makeGUIMainMenu","params","checkXZBounds","autoRotateBox","restart","autoRotateBoxCtrl","setValue","_generateParticles","mainMenu","_gui","onChange","value","setEnabled","_onPaused","angleX","angleY","transfo","boxVertices","ymin","v","min","transform","quat","invert","tmp","m","t","multiplyToRef","qf","decompose"],"sourceRoot":""}