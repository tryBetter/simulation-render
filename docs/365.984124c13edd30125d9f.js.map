{"version":3,"file":"365.984124c13edd30125d9f.js","mappings":"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","sources":["webpack://babylonjs-fluid-rendering/./src/assets/scenes/scene_b.glb","webpack://babylonjs-fluid-rendering/./src/scenes/fluidSimulationDemoBoxSphere.ts"],"sourcesContent":["export default __webpack_public_path__ + \"3a7e30d32bdbb158c31616b73b274b90.glb\";","import * as BABYLON from \"@babylonjs/core\";\n\nimport * as LiLGUI from \"lil-gui\";\n\nimport { FluidSimulationDemoBase } from \"./fluidSimulationDemoBase\";\nimport { ICollisionShape } from \"./Utils/sdfHelper\";\nimport myBox from \"../assets/scenes/scene_b.glb\";\nexport class FluidSimulationDemoBoxSphere extends FluidSimulationDemoBase {\n    private _checkXZBounds: boolean;\n    private _sphereMesh: BABYLON.Nullable<BABYLON.Mesh> = null;\n    private _boxMin: BABYLON.Vector3;\n    private _boxMax: BABYLON.Vector3;\n    private _boxMesh: BABYLON.Nullable<BABYLON.Mesh>;\n    private _boxMaterial: BABYLON.Nullable<BABYLON.PBRMaterial>;\n    private _boxMeshFront: BABYLON.Nullable<BABYLON.Mesh>;\n    private _boxMaterialFront: BABYLON.Nullable<BABYLON.PBRMaterial>;\n    private _origCollisionPlanes: Array<BABYLON.Plane>;\n    private _collisionPlanes: Array<\n        [BABYLON.Nullable<BABYLON.Mesh>, ICollisionShape]\n    >;\n    private _angleX: number;\n    private _angleY: number;\n    private _prevTransfo: BABYLON.Matrix;\n    private _autoRotateBox: boolean;\n    private _wallMesh: BABYLON.Nullable<BABYLON.Mesh> = null;\n    private _wallMesh1: BABYLON.Nullable<BABYLON.Mesh> = null;\n    private _wallMesh2: BABYLON.Nullable<BABYLON.Mesh> = null;\n    private _wallMesh3: BABYLON.Nullable<BABYLON.Mesh> = null;\n    // private _passPP: BABYLON.PostProcess;\n    private _sceneRenderObserver: BABYLON.Nullable<\n        BABYLON.Observer<BABYLON.Scene>\n    >;\n    private _sceneAfterCameraRenderObserver: BABYLON.Nullable<\n        BABYLON.Observer<BABYLON.Camera>\n    >;\n    private _sceneKeyboardObserver: BABYLON.Nullable<\n        BABYLON.Observer<BABYLON.KeyboardInfo>\n    >;\n    private _onEngineResizeObserver: BABYLON.Nullable<\n        BABYLON.Observer<BABYLON.Engine>\n    >;\n    private _customRootMesh :BABYLON.Nullable<BABYLON.Mesh> = null;\n    private _globalScale = 0.5;\n\n    constructor(scene: BABYLON.Scene) {\n        super(scene);\n\n        const halfSize = 0.35 * this._globalScale;\n        this._boxMin = new BABYLON.Vector3(-halfSize, -halfSize, -halfSize);\n        this._boxMax = new BABYLON.Vector3(halfSize, halfSize, halfSize);\n        this._boxMesh = null;\n        this._boxMaterial = null;\n        this._boxMeshFront = null;\n        this._boxMaterialFront = null;\n\n        this._checkXZBounds = true;\n        this._origCollisionPlanes = [\n            new BABYLON.Plane(0, 0, -1, Math.abs(this._boxMax.z)),\n            new BABYLON.Plane(0, 0, 1, Math.abs(this._boxMin.z)),\n            new BABYLON.Plane(1, 0, 0, Math.abs(this._boxMin.x)),\n            new BABYLON.Plane(-1, 0, 0, Math.abs(this._boxMax.x)),\n            new BABYLON.Plane(0, -1, 0, Math.abs(this._boxMax.y)),\n            new BABYLON.Plane(0, 1, 0, Math.abs(this._boxMin.y)),\n            new BABYLON.Plane(0, 1, 0, Math.abs(this._boxMin.y)),\n        ];\n        this._collisionPlanes = [];\n        for (let i = 0; i < this._origCollisionPlanes.length; ++i) {\n            const plane = this._origCollisionPlanes[i];\n            this.addCollisionPlane(\n                plane.normal,\n                plane.d,\n                i === this._origCollisionPlanes.length - 1 ? 0.98 : undefined\n            );\n        }\n\n        this._angleX = 0;\n        this._angleY = 0;\n        this._prevTransfo = BABYLON.Matrix.Identity();\n        this._autoRotateBox = false;\n\n        this._sceneRenderObserver = null;\n        this._sceneAfterCameraRenderObserver = null;\n        this._sceneKeyboardObserver = null;\n        this._onEngineResizeObserver = null;\n\n        // this._passPP = new BABYLON.PassPostProcess(\n        //     \"pass\",\n        //     1,\n        //     null,\n        //     undefined,\n        //     this._engine\n        // );\n        // this._passPP.externalTextureSamplerBinding = true;\n\n        this._wallMesh = null;\n        this._wallMesh1 = null;\n        this._wallMesh2 = null;\n        this._wallMesh3 = null;\n        this.addCollisionBox(\n            new BABYLON.Vector3(0.025, 0.0, 0.0),\n            new BABYLON.Vector3((90 * Math.PI) / 180, 0, 0),\n            new BABYLON.Vector3(0.1, 0.005, 0.1),\n        );\n        this.addCollisionBox(\n            new BABYLON.Vector3(0.025, 0.0, 0.035),\n            new BABYLON.Vector3((90 * Math.PI) / 180, 0, 0),\n            new BABYLON.Vector3(0.1, 0.005, 0.1),\n        );\n        this.addCollisionBox(\n            new BABYLON.Vector3(0.025, 0.0, -0.035),\n            new BABYLON.Vector3((90 * Math.PI) / 180, 0, 0),\n            new BABYLON.Vector3(0.1, 0.005, 0.1),\n        );\n\n        this.addCollisionBox(\n            new BABYLON.Vector3(0.025, 0.0, -0.07),\n            new BABYLON.Vector3((90 * Math.PI) / 180, 0, 0),\n            new BABYLON.Vector3(0.1, 0.005, 0.1),\n        );\n\n        this.loadCustomModel();\n        this._setCustomDebugLayer();\n        this._initMyPostProcessPipeline();\n    }\n\n    private _initMyPostProcessPipeline() {\n        const defaultPPLine = new BABYLON.DefaultRenderingPipeline(\n            \"defaultPipeline\", // The name of the pipeline\n            true, // Do you want the pipeline to use HDR texture?\n            this._scene, // The scene instance\n            [this._scene.activeCamera!] // The list of cameras to be attached to\n        );\n        defaultPPLine.samples = 2;\n        defaultPPLine.depthOfFieldEnabled = true;\n        defaultPPLine.depthOfField.focalLength = 246.4;\n        defaultPPLine.depthOfField.fStop = 32;\n        defaultPPLine.depthOfField.focusDistance = 1000;\n        defaultPPLine.depthOfField.lensSize = 6;\n\n        defaultPPLine.fxaaEnabled = true;\n        defaultPPLine.fxaa.samples = 4;\n        defaultPPLine.imageProcessingEnabled = true;\n        defaultPPLine.imageProcessing.contrast = 1.8;\n        defaultPPLine.imageProcessing.exposure = 2.2;\n        defaultPPLine.imageProcessing.toneMappingEnabled = false;\n        defaultPPLine.imageProcessing.toneMappingType = BABYLON.ImageProcessingConfiguration.TONEMAPPING_ACES;\n        defaultPPLine.glowLayerEnabled = true;\n        if (defaultPPLine.glowLayer) {\n            defaultPPLine.glowLayer.blurKernelSize = 16;\n            defaultPPLine.glowLayer.intensity = 1.0;\n        }\n        // defaultPPLine.grainEnabled = true;\n        // defaultPPLine.grain.animated = true;\n        // defaultPPLine.grain.intensity = 8.2;\n        defaultPPLine.bloomEnabled = true;\n    }\n\n    _setCustomDebugLayer() {\n        type di = {\n            [key: string]: boolean\n          }\n          const debugKeyInfo: di = {\n            'Shift': false,\n            'D': false\n          }\n          this._scene.onKeyboardObservable.add((kbInfo) => {\n            switch (kbInfo.type) {\n              case BABYLON.KeyboardEventTypes.KEYDOWN:\n                debugKeyInfo[kbInfo.event.key] = true\n                break;\n              case BABYLON.KeyboardEventTypes.KEYUP:\n                debugKeyInfo[kbInfo.event.key] = false\n                break;\n            }\n            if (debugKeyInfo['Shift'] && debugKeyInfo['D']) {\n              this._scene.debugLayer.isVisible() ? this._scene.debugLayer.hide() : this._scene.debugLayer.show({\n                overlay: true\n              })\n            }\n          });\n    }\n\n    loadCustomModel() {\n        let boolBox: BABYLON.Mesh | undefined = undefined;\n        let water: BABYLON.Mesh | undefined = undefined;\n        let waterWave: BABYLON.Mesh | undefined = undefined;\n        BABYLON.SceneLoader.AppendAsync(\"\", myBox, this._scene).then((importResult) => {\n            this._customRootMesh = importResult.getMeshByName(\"__root__\") as BABYLON.Mesh;\n            const scaleMesh = 0.1 * this._globalScale;\n            this._customRootMesh?.scaling.set(scaleMesh,scaleMesh,scaleMesh)\n      \n            const lightConfig = [\n              {\n                intensity: 0,\n                diffuseColor: BABYLON.Color3.FromInts(0.686 * 255, 255, 0.275 * 255),\n                specularColor: BABYLON.Color3.FromInts(0, 0.871 * 255, 255),\n                position: new BABYLON.Vector3(0, 0, -6.294),\n              },\n              {\n                intensity: 0,\n                diffuseColor: BABYLON.Color3.FromInts(0, 0.863 * 255, 255),\n                specularColor: BABYLON.Color3.FromInts(0, 255, 0.678 * 255),\n                position: new BABYLON.Vector3(0.178, -0.037, 6.285),\n              }\n            ]\n            let lightNode: BABYLON.TransformNode|undefined = undefined;\n            importResult.lights.forEach((light, index) => {\n              const pLight = light as BABYLON.PointLight;\n              if (lightNode === undefined) {\n                lightNode = pLight.parent as BABYLON.TransformNode;\n                lightNode.position.set(0, 0, 0);\n              }\n              lightNode.position.set(0,0,0);\n              pLight.parent = lightNode;\n              pLight.position.copyFrom(lightConfig[index].position);\n              pLight.intensity = lightConfig[index].intensity;\n              pLight.diffuse.copyFrom(lightConfig[index].diffuseColor);\n              pLight.specular.copyFrom(lightConfig[index].specularColor);\n            })\n      \n            this._scene.registerBeforeRender(() => {\n              if (lightNode !== undefined) {\n                lightNode.rotationQuaternion = null\n                lightNode.rotation.y = ((this._scene.activeCameras?.[0] ?? this._scene.activeCamera) as any)!.alpha + Math.PI;\n              }\n            });\n      \n            const renderList: any[] = []\n            importResult.meshes.forEach((mesh)=> {\n              if (mesh && mesh.name && mesh.material) {\n            //   (mesh.material as BABYLON.PBRMaterial).maxSimultaneousLights = 8\n              switch (mesh.name) {\n                case \"立方体.006_Baked\":\n                  mesh.material.alpha = 0.4\n                  mesh.alphaIndex = 4;\n                  mesh.material.transparencyMode = BABYLON.Material.MATERIAL_ALPHABLEND\n                  mesh.material.alphaMode = BABYLON.Engine.ALPHA_COMBINE;\n                  // eslint-disable-next-line no-case-declarations\n                  const boxMat: BABYLON.PBRMaterial = (mesh.material as BABYLON.PBRMaterial);\n                  boxMat.metallic = 1;\n                  boxMat.roughness = 0.2;\n                  boxMat.albedoColor.r = 0.50;\n                  boxMat.albedoColor.g = 0.04;\n                  boxMat.albedoColor.b = 1.0;\n                  boxMat.metallicReflectanceColor.r = 0.97;\n                  boxMat.metallicReflectanceColor.g = 0.029;\n                  boxMat.metallicReflectanceColor.b = 1.0;\n                  boxMat.anisotropy.isEnabled = true;\n                  boxMat.anisotropy.intensity = 0.8;\n                  boxMat.sheen.isEnabled = true;\n                  boxMat.sheen.intensity = 1.0;\n                  boxMat.sheen.color.r = 0.816;\n                  boxMat.sheen.color.g = 0.006;\n                  boxMat.sheen.color.b = 1.0;\n                  boxMat.sheen.useRoughnessFromMainTexture = true;\n                  boxMat.subSurface.tintColor.r = 0.541;\n                  boxMat.subSurface.tintColor.g = 0.933;\n                  boxMat.subSurface.tintColor.b = 1.0;\n                  boxMat.subSurface.isScatteringEnabled = true;\n                  boxMat.subSurface.isTranslucencyEnabled = true;\n                  boxMat.disableDepthWrite = true\n      \n                  break;\n                case \"布尔\":\n                  mesh.visibility = 0\n                  boolBox = mesh as BABYLON.Mesh;\n                  break;\n                case \"柱体.001_Baked\":\n                  mesh.visibility = 0\n                  break;\n                case \"平面_primitive0\":\n                  mesh.visibility = 0\n                  water = mesh as BABYLON.Mesh;\n                  break;\n                case \"平面_primitive1\":\n                  mesh.visibility = 0\n                  waterWave = mesh as BABYLON.Mesh;\n                  break;\n                case \"边线_Baked\":\n                  mesh.visibility = 0\n                  break;\n                case \"立方体.011_Baked\":\n                  renderList.push(mesh)\n                  mesh.alphaIndex = 3\n                  // mesh.material.disableDepthWrite = true;\n                  mesh.material.alpha = 0.6\n                  mesh.material.transparencyMode = BABYLON.Material.MATERIAL_ALPHABLEND;\n                  mesh.material.alphaMode = BABYLON.Engine.ALPHA_COMBINE;\n                  // (mesh.material as PBRMaterial).emissiveColor = Color3.FromInts(0.141,0, 0.482);\n                  (mesh.material as BABYLON.PBRMaterial).emissiveColor = BABYLON.Color3.FromInts(3.4,0, 51);\n                  (mesh.material as BABYLON.PBRMaterial).metallic = 1.0;\n                  (mesh.material as BABYLON.PBRMaterial).roughness = 0.0;\n                  break;\n                case \"立方体.013_Baked\":\n                  renderList.push(mesh)\n                  mesh.alphaIndex = 3\n                  // mesh.material.disableDepthWrite = true;\n                  mesh.material.alpha = 0.4\n                  mesh.material.transparencyMode = BABYLON.Material.MATERIAL_ALPHABLEND;\n                  mesh.material.alphaMode = BABYLON.Engine.ALPHA_COMBINE;\n                  (mesh.material as BABYLON.PBRMaterial).emissiveColor = BABYLON.Color3.FromInts(12.6,0, 148);\n                  (mesh.material as BABYLON.PBRMaterial).metallic = 0.93;\n                  (mesh.material as BABYLON.PBRMaterial).roughness = 0.0;\n                  break;\n                case \"立方体.012_Baked\":\n                case \"立方体.014_Baked\":\n                  renderList.push(mesh)\n                  mesh.alphaIndex = 3\n                  mesh.material.alpha = 0.26\n                  mesh.material.transparencyMode = BABYLON.Material.MATERIAL_ALPHABLEND\n                  mesh.material.alphaMode = BABYLON.Engine.ALPHA_ADD;\n                  (mesh.material as BABYLON.PBRMaterial).emissiveColor = BABYLON.Color3.FromInts(0.059,0.161, 1.0);\n                  (mesh.material as BABYLON.PBRMaterial).metallic = 1.0;\n                  (mesh.material as BABYLON.PBRMaterial).roughness = 0.15;\n                  break;\n                case \"Cylinder\":\n                  break;\n                default:\n                  break;\n              }\n              }\n            })\n          })\n    }\n\n    protected async _run() {\n        // Get collision meshes\n        for (let i = 0; i < this._origCollisionPlanes.length; ++i) {\n            this._collisionPlanes.push(this._collisionObjects[i]);\n        }\n\n        this._collisionPlanes[this._collisionPlanes.length - 1][1].disabled = true;\n\n        this._wallMesh = this._collisionObjects[this._origCollisionPlanes.length][0];\n        this._wallMesh1 = this._collisionObjects[this._origCollisionPlanes.length + 1][0];\n        this._wallMesh2 = this._collisionObjects[this._origCollisionPlanes.length + 2][0];\n        this._wallMesh3 = this._collisionObjects[this._origCollisionPlanes.length + 3][0];\n        if (this._wallMesh && this._wallMesh.material) {\n            this._wallMesh.material.alpha = 0.0;\n        }\n        if (this._wallMesh1 && this._wallMesh1.material) {\n            this._wallMesh1.material.alpha = 0.0;\n        }\n        if (this._wallMesh2 && this._wallMesh2.material) {\n            this._wallMesh2.material.alpha = 0.0;\n        }\n        if (this._wallMesh3 && this._wallMesh3.material) {\n            this._wallMesh3.material.alpha = 0.0;\n        }\n        \n\n        // Reset camera\n        const camera = this._scene.activeCameras?.[0] ?? this._scene.activeCamera;\n        \n        const tempScene = new BABYLON.Scene(this._scene.getEngine());\n        const tempCamera = new BABYLON.ArcRotateCamera(\"camera\", 14.33, 1.594, this._globalScale, BABYLON.Vector3.Zero(), tempScene);\n        tempCamera.lowerRadiusLimit = this._globalScale;\n        tempCamera.upperRadiusLimit = this._globalScale;\n        tempCamera.useAutoRotationBehavior = true;\n        tempCamera.attachControl(document.getElementById(\"renderCanvas\"), true);\n        tempScene.attachControl(true,true,true);\n        tempScene.clearColor = new BABYLON.Color4(0, 0, 0, 0);\n        tempScene.autoClear = false\n\n        this._scene.onAfterCameraRenderObservable.add(() => {\n            tempScene.render()\n            if (this._customRootMesh) {\n                this._customRootMesh.rotationQuaternion = tempCamera.absoluteRotation;\n                this._rotateMeshes(-tempCamera.alpha, -tempCamera.beta);\n            }\n        })\n\n        if (camera) {\n            (camera as BABYLON.ArcRotateCamera).alpha = 1;\n            (camera as BABYLON.ArcRotateCamera).beta = 1.1;\n            (camera as BABYLON.ArcRotateCamera).radius = 1.9;\n            (camera as BABYLON.ArcRotateCamera).panningSensibility = 0;\n            (camera as BABYLON.ArcRotateCamera).lowerAlphaLimit = 1;\n            (camera as BABYLON.ArcRotateCamera).upperAlphaLimit = 1;\n            (camera as BABYLON.ArcRotateCamera).lowerBetaLimit = 1.1;\n            (camera as BABYLON.ArcRotateCamera).upperBetaLimit = 1.1;\n            (camera as BABYLON.ArcRotateCamera).lowerRadiusLimit = 1.9 * this._globalScale;\n            (camera as BABYLON.ArcRotateCamera).upperRadiusLimit = 1.9 * this._globalScale;\n\n            // camera.outputRenderTarget = new BABYLON.RenderTargetTexture(\n            //     \"rttFinal\",\n            //     {\n            //         width: this._engine.getRenderWidth(),\n            //         height: this._engine.getRenderHeight(),\n            //     },\n            //     this._scene\n            // );\n        }\n\n        // Simulation parameters\n        this._fluidRenderObject.object.particleSize = 0.03;\n        this._fluidRenderObject.object.particleThicknessAlpha = 0.017;\n\n        this._fluidSim!.smoothingRadius = 0.05;\n        this._fluidSim!.densityReference = 10000;\n        this._fluidSim!.pressureConstant = 0.4;\n        this._fluidSim!.viscosity = 0.002;\n        this._fluidSim!.maxVelocity = 6;\n        this._fluidSim!.maxAcceleration = 10000;\n\n        // Create materials\n        // this._boxMaterial = new BABYLON.PBRMaterial(\"BoxMeshMat\", this._scene);\n        // this._boxMaterial.metallic = 0.3;\n        // this._boxMaterial.roughness = 0;\n        // this._boxMaterial.alpha = 0.0;\n        // this._boxMaterial.backFaceCulling = true;\n        // this._boxMaterial.cullBackFaces = false;\n\n        // this._boxMaterialFront = this._boxMaterial.clone(\"BoxMeshFrontMat\");\n        // this._boxMaterialFront.cullBackFaces = true;\n\n        // Create meshes\n        // this._boxMesh = BABYLON.MeshBuilder.CreateBox(\n        //     \"boxMesh\",\n        //     {\n        //         width: this._boxMax.x - this._boxMin.x,\n        //         height: this._boxMax.y - this._boxMin.y,\n        //         depth: this._boxMax.z - this._boxMin.z,\n        //     },\n        //     this._scene\n        // );\n        // this._boxMesh.material = this._boxMaterial;\n        // this._boxMesh.position.x = (this._boxMin.x + this._boxMax.x) / 2;\n        // this._boxMesh.position.y = (this._boxMin.y + this._boxMax.y) / 2;\n        // this._boxMesh.position.z = (this._boxMin.z + this._boxMax.z) / 2;\n        // this._boxMesh.isPickable = false;\n\n        // this._boxMeshFront = this._boxMesh.clone(\"boxMeshFront\");\n        // this._boxMeshFront.material = this._boxMaterialFront;\n        // this._boxMeshFront.layerMask = 0x10000000; // make sure the mesh is not displayed by the camera - we will display it ourselves by a direct call to render()\n\n        // Render the front side of the box\n        // this._passPP.onApplyObservable.add((effect) => {\n        //     effect.setTexture(\"textureSampler\", camera!.outputRenderTarget);\n        // });\n\n        // let depthIsShared = false;\n        // this._sceneAfterCameraRenderObserver =\n        //     this._scene.onAfterCameraRenderObservable.add(() => {\n        //         const firstPP = camera?._getFirstPostProcess();\n        //         if (\n        //             firstPP &&\n        //             firstPP.inputTexture.depthStencilTexture &&\n        //             !depthIsShared\n        //         ) {\n        //             firstPP.inputTexture._shareDepth(\n        //                 camera!.outputRenderTarget!.renderTarget!\n        //             );\n        //             depthIsShared = true;\n        //         }\n        //         if (depthIsShared) {\n        //             this._boxMeshFront?.render(\n        //                 this._boxMeshFront.subMeshes[0],\n        //                 true\n        //             );\n        //         }\n        //     });\n\n        this._onEngineResizeObserver = this._engine.onResizeObservable.add(\n            () => {\n                camera?.outputRenderTarget?.resize({\n                    width: this._engine.getRenderWidth(true),\n                    height: this._engine.getRenderHeight(true),\n                });\n                // depthIsShared = false;\n            }\n        );\n\n        super._run().then(() => {\n            setTimeout(() => {\n                document.getElementById(\"renderCanvas\")!.style.opacity = \"1.0\";\n            }, 2800)\n        });\n    }\n\n    public dispose(): void {\n        super.dispose();\n\n        const camera =\n            this._scene.activeCameras?.[0] ?? this._scene.activeCamera;\n\n        if (camera) {\n            camera.outputRenderTarget?.dispose();\n            camera.outputRenderTarget = null;\n        }\n\n        this._scene.onBeforeRenderObservable.remove(this._sceneRenderObserver);\n        this._scene.onAfterCameraRenderObservable.remove(\n            this._sceneAfterCameraRenderObserver\n        );\n        this._scene.onKeyboardObservable.remove(this._sceneKeyboardObserver);\n\n        // this._passPP.dispose();\n        this._boxMesh?.dispose();\n        this._boxMeshFront?.dispose();\n        this._boxMaterial?.dispose();\n        this._engine.onResizeObservable.remove(this._onEngineResizeObserver);\n    }\n\n    protected _makeGUIMainMenu(): void {\n        const params = {\n            checkXZBounds: true,\n            autoRotateBox: false,\n            restart: () => {\n                this._angleX = this._angleY = 0;\n                this._autoRotateBox = false;\n                autoRotateBoxCtrl?.setValue(false);\n                this._rotateMeshes(0, 0);\n                this._generateParticles();\n            },\n            // boxOpacity: this._boxMaterial!.alpha,\n        };\n\n        const mainMenu = this._gui!;\n\n        let autoRotateBoxCtrl: BABYLON.Nullable<LiLGUI.Controller> = null;\n\n        mainMenu.add(params, \"restart\").name(\"Restart\");\n\n        mainMenu\n            .add(params, \"checkXZBounds\")\n            .name(\"Check box bounds\")\n            .onChange((value: boolean) => {\n                this._checkXZBounds = value;\n                this._boxMesh?.setEnabled(value);\n                this._boxMeshFront?.setEnabled(value);\n                for (let i = 0; i < this._collisionPlanes.length; ++i) {\n                    this._collisionPlanes[i][1].disabled =\n                        (!value && i < this._collisionPlanes.length - 1) ||\n                        (value && i === this._collisionPlanes.length - 1);\n                }\n                if (!value) {\n                    this._autoRotateBox = false;\n                    autoRotateBoxCtrl?.setValue(false);\n                }\n            });\n\n        autoRotateBoxCtrl = mainMenu\n            .add(params, \"autoRotateBox\")\n            .name(\"Auto rotate box\")\n            .onChange((value: boolean) => {\n                this._autoRotateBox = value;\n            });\n\n        // mainMenu\n        //     .add(params, \"boxOpacity\", 0, 1, 0.01)\n        //     .name(\"Box opacity\")\n        //     .onChange((value: any) => {\n        //         this._boxMaterial!.alpha = value;\n        //         this._boxMaterialFront!.alpha = value;\n        //     });\n    }\n\n    protected _onPaused(value: boolean) {\n        super._onPaused(value);\n\n        if (value) {\n            this._autoRotateBox = false;\n        }\n    }\n\n    protected _rotateMeshes(angleX: number, angleY: number): void {\n        const transfo = BABYLON.Matrix.RotationYawPitchRoll(\n            angleX,\n            0,\n            angleY,\n        );\n\n        const boxVertices = [\n            new BABYLON.Vector3(this._boxMin.x, this._boxMin.y, this._boxMin.z),\n            new BABYLON.Vector3(this._boxMin.x, this._boxMax.y, this._boxMin.z),\n            new BABYLON.Vector3(this._boxMin.x, this._boxMax.y, this._boxMax.z),\n            new BABYLON.Vector3(this._boxMin.x, this._boxMin.y, this._boxMax.z),\n            new BABYLON.Vector3(this._boxMax.x, this._boxMin.y, this._boxMin.z),\n            new BABYLON.Vector3(this._boxMax.x, this._boxMax.y, this._boxMin.z),\n            new BABYLON.Vector3(this._boxMax.x, this._boxMax.y, this._boxMax.z),\n            new BABYLON.Vector3(this._boxMax.x, this._boxMin.y, this._boxMax.z),\n        ];\n\n        let ymin = 1e10;\n        for (let i = 0; i < boxVertices.length; ++i) {\n            const v = BABYLON.Vector3.TransformCoordinates(\n                boxVertices[i],\n                transfo\n            );\n            ymin = Math.min(ymin, v.y);\n        }\n\n        this._collisionPlanes[\n            this._origCollisionPlanes.length - 1\n        ][1].params[1] = Math.abs(ymin) + 0.02;\n\n        for (let i = 0; i < this._origCollisionPlanes.length - 1; ++i) {\n            const plane = this._origCollisionPlanes[i].transform(transfo);\n            this._collisionPlanes[i][1].params = [plane.normal, plane.d];\n        }\n\n        const quat = BABYLON.Quaternion.FromRotationMatrix(transfo);\n\n        this._prevTransfo.invert();\n\n        if (this._sphereMesh) {\n            const tmp = BABYLON.Vector3.TransformCoordinates(\n                this._sphereMesh.position,\n                this._prevTransfo\n            );\n\n            this._sphereMesh.rotationQuaternion = quat;\n            this._sphereMesh.position = BABYLON.Vector3.TransformCoordinates(\n                tmp,\n                transfo\n            );\n        }\n\n        if (this._wallMesh) {\n            const tmp = BABYLON.Vector3.TransformCoordinates(\n                this._wallMesh.position,\n                this._prevTransfo\n            );\n\n            const m = BABYLON.Matrix.RotationYawPitchRoll(\n                0,\n                (90 * Math.PI) / 180,\n                0\n            );\n            const t = BABYLON.Matrix.Translation(tmp.x, tmp.y, tmp.z);\n\n            m.multiplyToRef(t, m).multiplyToRef(transfo, m);\n            const qf =\n                this._wallMesh.rotationQuaternion ?? new BABYLON.Quaternion();\n\n            m.decompose(undefined, qf, this._wallMesh.position);\n\n            this._wallMesh.rotationQuaternion = qf;\n        }\n        \n        if (this._wallMesh1) {\n            const tmp = BABYLON.Vector3.TransformCoordinates(\n                this._wallMesh1.position,\n                this._prevTransfo\n            );\n\n            const m = BABYLON.Matrix.RotationYawPitchRoll(\n                0,\n                (90 * Math.PI) / 180,\n                0\n            );\n            const t = BABYLON.Matrix.Translation(tmp.x, tmp.y, tmp.z);\n\n            m.multiplyToRef(t, m).multiplyToRef(transfo, m);\n            const qf =\n                this._wallMesh1.rotationQuaternion ?? new BABYLON.Quaternion();\n\n            m.decompose(undefined, qf, this._wallMesh1.position);\n\n            this._wallMesh1.rotationQuaternion = qf;\n        }\n        \n        if (this._wallMesh2) {\n            const tmp = BABYLON.Vector3.TransformCoordinates(\n                this._wallMesh2.position,\n                this._prevTransfo\n            );\n\n            const m = BABYLON.Matrix.RotationYawPitchRoll(\n                0,\n                (90 * Math.PI) / 180,\n                0\n            );\n            const t = BABYLON.Matrix.Translation(tmp.x, tmp.y, tmp.z);\n\n            m.multiplyToRef(t, m).multiplyToRef(transfo, m);\n            const qf =\n                this._wallMesh2.rotationQuaternion ?? new BABYLON.Quaternion();\n\n            m.decompose(undefined, qf, this._wallMesh2.position);\n\n            this._wallMesh2.rotationQuaternion = qf;\n        }\n        if (this._wallMesh3) {\n            const tmp = BABYLON.Vector3.TransformCoordinates(\n                this._wallMesh3.position,\n                this._prevTransfo\n            );\n\n            const m = BABYLON.Matrix.RotationYawPitchRoll(\n                0,\n                (90 * Math.PI) / 180,\n                0\n            );\n            const t = BABYLON.Matrix.Translation(tmp.x, tmp.y, tmp.z);\n\n            m.multiplyToRef(t, m).multiplyToRef(transfo, m);\n            const qf =\n                this._wallMesh3.rotationQuaternion ?? new BABYLON.Quaternion();\n\n            m.decompose(undefined, qf, this._wallMesh3.position);\n\n            this._wallMesh3.rotationQuaternion = qf;\n        }\n\n        if (this._boxMesh && this._boxMeshFront) {\n            this._boxMesh.rotationQuaternion =\n                this._boxMeshFront.rotationQuaternion = quat;\n            this._boxMesh.position.x = (this._boxMin.x + this._boxMax.x) / 2;\n            this._boxMesh.position.y = (this._boxMin.y + this._boxMax.y) / 2;\n            this._boxMesh.position.z = (this._boxMin.z + this._boxMax.z) / 2;\n            this._boxMesh.position = BABYLON.Vector3.TransformCoordinates(\n                this._boxMesh.position,\n                transfo\n            );\n            this._boxMeshFront.position = this._boxMesh.position;\n        }\n\n        this._prevTransfo.copyFrom(transfo);\n    }\n}\n"],"names":["FluidSimulationDemoBoxSphere","FluidSimulationDemoBase","constructor","scene","super","_sphereMesh","_wallMesh","_wallMesh1","_wallMesh2","_wallMesh3","_customRootMesh","_globalScale","halfSize","this","_boxMin","_boxMax","_boxMesh","_boxMaterial","_boxMeshFront","_boxMaterialFront","_checkXZBounds","_origCollisionPlanes","Math","abs","z","x","y","_collisionPlanes","i","length","plane","addCollisionPlane","normal","d","undefined","_angleX","_angleY","_prevTransfo","_autoRotateBox","_sceneRenderObserver","_sceneAfterCameraRenderObserver","_sceneKeyboardObserver","_onEngineResizeObserver","addCollisionBox","PI","loadCustomModel","_setCustomDebugLayer","_initMyPostProcessPipeline","defaultPPLine","_scene","activeCamera","samples","depthOfFieldEnabled","depthOfField","focalLength","fStop","focusDistance","lensSize","fxaaEnabled","fxaa","imageProcessingEnabled","imageProcessing","contrast","exposure","toneMappingEnabled","toneMappingType","glowLayerEnabled","glowLayer","blurKernelSize","intensity","bloomEnabled","debugKeyInfo","onKeyboardObservable","add","kbInfo","type","event","key","debugLayer","isVisible","hide","show","overlay","boolBox","water","waterWave","then","importResult","getMeshByName","scaleMesh","scaling","set","lightConfig","diffuseColor","specularColor","position","lightNode","lights","forEach","light","index","pLight","parent","copyFrom","diffuse","specular","registerBeforeRender","rotationQuaternion","rotation","activeCameras","alpha","renderList","meshes","mesh","name","material","alphaIndex","transparencyMode","alphaMode","boxMat","metallic","roughness","albedoColor","r","g","b","metallicReflectanceColor","anisotropy","isEnabled","sheen","color","useRoughnessFromMainTexture","subSurface","tintColor","isScatteringEnabled","isTranslucencyEnabled","disableDepthWrite","visibility","push","emissiveColor","async","_collisionObjects","disabled","camera","tempScene","getEngine","tempCamera","lowerRadiusLimit","upperRadiusLimit","useAutoRotationBehavior","attachControl","document","getElementById","clearColor","autoClear","onAfterCameraRenderObservable","render","absoluteRotation","_rotateMeshes","beta","radius","panningSensibility","lowerAlphaLimit","upperAlphaLimit","lowerBetaLimit","upperBetaLimit","_fluidRenderObject","object","particleSize","particleThicknessAlpha","_fluidSim","smoothingRadius","densityReference","pressureConstant","viscosity","maxVelocity","maxAcceleration","_engine","onResizeObservable","outputRenderTarget","resize","width","getRenderWidth","height","getRenderHeight","_run","setTimeout","style","opacity","dispose","onBeforeRenderObservable","remove","_makeGUIMainMenu","params","checkXZBounds","autoRotateBox","restart","autoRotateBoxCtrl","setValue","_generateParticles","mainMenu","_gui","onChange","value","setEnabled","_onPaused","angleX","angleY","transfo","boxVertices","ymin","v","min","transform","quat","invert","tmp","m","t","multiplyToRef","qf","decompose"],"sourceRoot":""}