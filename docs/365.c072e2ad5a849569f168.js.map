{"version":3,"file":"365.c072e2ad5a849569f168.js","mappings":"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","sources":["webpack://babylonjs-fluid-rendering/./src/assets/scenes/scene_b.glb","webpack://babylonjs-fluid-rendering/./src/scenes/fluidSimulationDemoBoxSphere.ts"],"sourcesContent":["export default __webpack_public_path__ + \"3a7e30d32bdbb158c31616b73b274b90.glb\";","import * as BABYLON from \"@babylonjs/core\";\n\nimport * as LiLGUI from \"lil-gui\";\n\nimport { FluidSimulationDemoBase } from \"./fluidSimulationDemoBase\";\nimport { ICollisionShape } from \"./Utils/sdfHelper\";\nimport myBox from \"../assets/scenes/scene_b.glb\";\nexport class FluidSimulationDemoBoxSphere extends FluidSimulationDemoBase {\n    private _checkXZBounds: boolean;\n    private _sphereMesh: BABYLON.Nullable<BABYLON.Mesh> = null;\n    private _boxMin: BABYLON.Vector3;\n    private _boxMax: BABYLON.Vector3;\n    private _boxMesh: BABYLON.Nullable<BABYLON.Mesh>;\n    private _boxMaterial: BABYLON.Nullable<BABYLON.PBRMaterial>;\n    private _boxMeshFront: BABYLON.Nullable<BABYLON.Mesh>;\n    private _boxMaterialFront: BABYLON.Nullable<BABYLON.PBRMaterial>;\n    private _origCollisionPlanes: Array<BABYLON.Plane>;\n    private _collisionPlanes: Array<\n        [BABYLON.Nullable<BABYLON.Mesh>, ICollisionShape]\n    >;\n    private _angleX: number;\n    private _angleY: number;\n    private _prevTransfo: BABYLON.Matrix;\n    private _autoRotateBox: boolean;\n    private _wallMesh: BABYLON.Nullable<BABYLON.Mesh> = null;\n    // private _passPP: BABYLON.PostProcess;\n    private _sceneRenderObserver: BABYLON.Nullable<\n        BABYLON.Observer<BABYLON.Scene>\n    >;\n    private _sceneAfterCameraRenderObserver: BABYLON.Nullable<\n        BABYLON.Observer<BABYLON.Camera>\n    >;\n    private _sceneKeyboardObserver: BABYLON.Nullable<\n        BABYLON.Observer<BABYLON.KeyboardInfo>\n    >;\n    private _onEngineResizeObserver: BABYLON.Nullable<\n        BABYLON.Observer<BABYLON.Engine>\n    >;\n    private _customRootMesh :BABYLON.Nullable<BABYLON.Mesh> = null;\n\n    constructor(scene: BABYLON.Scene) {\n        super(scene);\n\n        const halfSize = 0.35;\n        this._boxMin = new BABYLON.Vector3(-halfSize, -halfSize, -halfSize);\n        this._boxMax = new BABYLON.Vector3(halfSize, halfSize, halfSize);\n        this._boxMesh = null;\n        this._boxMaterial = null;\n        this._boxMeshFront = null;\n        this._boxMaterialFront = null;\n\n        this._checkXZBounds = true;\n        this._origCollisionPlanes = [\n            new BABYLON.Plane(0, 0, -1, Math.abs(this._boxMax.z)),\n            new BABYLON.Plane(0, 0, 1, Math.abs(this._boxMin.z)),\n            new BABYLON.Plane(1, 0, 0, Math.abs(this._boxMin.x)),\n            new BABYLON.Plane(-1, 0, 0, Math.abs(this._boxMax.x)),\n            new BABYLON.Plane(0, -1, 0, Math.abs(this._boxMax.y)),\n            new BABYLON.Plane(0, 1, 0, Math.abs(this._boxMin.y)),\n            new BABYLON.Plane(0, 1, 0, Math.abs(this._boxMin.y)),\n        ];\n        this._collisionPlanes = [];\n        for (let i = 0; i < this._origCollisionPlanes.length; ++i) {\n            const plane = this._origCollisionPlanes[i];\n            this.addCollisionPlane(\n                plane.normal,\n                plane.d,\n                i === this._origCollisionPlanes.length - 1 ? 0.98 : undefined\n            );\n        }\n\n        this._angleX = 0;\n        this._angleY = 0;\n        this._prevTransfo = BABYLON.Matrix.Identity();\n        this._autoRotateBox = false;\n\n        this._sceneRenderObserver = null;\n        this._sceneAfterCameraRenderObserver = null;\n        this._sceneKeyboardObserver = null;\n        this._onEngineResizeObserver = null;\n\n        // this._passPP = new BABYLON.PassPostProcess(\n        //     \"pass\",\n        //     1,\n        //     null,\n        //     undefined,\n        //     this._engine\n        // );\n        // this._passPP.externalTextureSamplerBinding = true;\n\n        this.loadCustomModel();\n        this._setCustomDebugLayer();\n\n    }\n\n    _setCustomDebugLayer() {\n        type di = {\n            [key: string]: boolean\n          }\n          const debugKeyInfo: di = {\n            'Shift': false,\n            'D': false\n          }\n          this._scene.onKeyboardObservable.add((kbInfo) => {\n            switch (kbInfo.type) {\n              case BABYLON.KeyboardEventTypes.KEYDOWN:\n                debugKeyInfo[kbInfo.event.key] = true\n                break;\n              case BABYLON.KeyboardEventTypes.KEYUP:\n                debugKeyInfo[kbInfo.event.key] = false\n                break;\n            }\n            if (debugKeyInfo['Shift'] && debugKeyInfo['D']) {\n              this._scene.debugLayer.isVisible() ? this._scene.debugLayer.hide() : this._scene.debugLayer.show({\n                overlay: true\n              })\n            }\n          });\n    }\n\n    loadCustomModel() {\n        let boolBox: BABYLON.Mesh | undefined = undefined;\n        let water: BABYLON.Mesh | undefined = undefined;\n        let waterWave: BABYLON.Mesh | undefined = undefined;\n        BABYLON.SceneLoader.AppendAsync(\"\", myBox, this._scene).then((importResult) => {\n            // const eu = new BABYLON.Vector3(0, 0,20 / 180 * Math.PI)\n            // eu.reorderInPlace(\"YXZ\")\n            // importResult.meshes[0].rotateAround(BABYLON.Vector3.Zero(), BABYLON.Vector3.Right(), 0 / 180 * Math.PI)\n            this._customRootMesh = importResult.getMeshByName(\"__root__\") as BABYLON.Mesh;\n            this._customRootMesh?.scaling.set(0.1,0.1,0.1)\n      \n            const lightConfig = [\n              {\n                intensity: 0,\n                diffuseColor: BABYLON.Color3.FromInts(0.686 * 255, 255, 0.275 * 255),\n                specularColor: BABYLON.Color3.FromInts(0, 0.871 * 255, 255),\n                position: new BABYLON.Vector3(0, 0, -6.294),\n              },\n              {\n                intensity: 0,\n                diffuseColor: BABYLON.Color3.FromInts(0, 0.863 * 255, 255),\n                specularColor: BABYLON.Color3.FromInts(0, 255, 0.678 * 255),\n                position: new BABYLON.Vector3(0.178, -0.037, 6.285),\n              }\n            ]\n            let lightNode: BABYLON.TransformNode|undefined = undefined;\n            importResult.lights.forEach((light, index) => {\n              const pLight = light as BABYLON.PointLight;\n              if (lightNode === undefined) {\n                lightNode = pLight.parent as BABYLON.TransformNode;\n                lightNode.position.set(0, 0, 0);\n              }\n              lightNode.position.set(0,0,0);\n              pLight.parent = lightNode;\n              pLight.position.copyFrom(lightConfig[index].position);\n              pLight.intensity = lightConfig[index].intensity;\n              pLight.diffuse.copyFrom(lightConfig[index].diffuseColor);\n              pLight.specular.copyFrom(lightConfig[index].specularColor);\n            })\n      \n            this._scene.registerBeforeRender(() => {\n              if (lightNode !== undefined) {\n                lightNode.rotationQuaternion = null\n                lightNode.rotation.y = ((this._scene.activeCameras?.[0] ?? this._scene.activeCamera) as any)!.alpha + Math.PI;\n              }\n            });\n      \n            // const probe = new ReflectionProbe(\"boxReflection\", 512, scene);\n      \n            const renderList: any[] = []\n            importResult.meshes.forEach((mesh)=> {\n              if (mesh && mesh.name && mesh.material) {\n            //   (mesh.material as BABYLON.PBRMaterial).maxSimultaneousLights = 8\n              switch (mesh.name) {\n                case \"立方体.006_Baked\":\n                  mesh.material.alpha = 0.4\n                  mesh.alphaIndex = 4;\n                  mesh.material.transparencyMode = BABYLON.Material.MATERIAL_ALPHABLEND\n                  mesh.material.alphaMode = BABYLON.Engine.ALPHA_COMBINE;\n                  // eslint-disable-next-line no-case-declarations\n                  const boxMat: BABYLON.PBRMaterial = (mesh.material as BABYLON.PBRMaterial);\n                  boxMat.metallic = 1;\n                  boxMat.roughness = 0.2;\n                  boxMat.albedoColor.r = 0.50;\n                  boxMat.albedoColor.g = 0.04;\n                  boxMat.albedoColor.b = 1.0;\n                  boxMat.metallicReflectanceColor.r = 0.97;\n                  boxMat.metallicReflectanceColor.g = 0.029;\n                  boxMat.metallicReflectanceColor.b = 1.0;\n                  boxMat.anisotropy.isEnabled = true;\n                  boxMat.anisotropy.intensity = 0.8;\n                  boxMat.sheen.isEnabled = true;\n                  boxMat.sheen.intensity = 1.0;\n                  boxMat.sheen.color.r = 0.816;\n                  boxMat.sheen.color.g = 0.006;\n                  boxMat.sheen.color.b = 1.0;\n                  boxMat.sheen.useRoughnessFromMainTexture = true;\n                  boxMat.subSurface.tintColor.r = 0.541;\n                  boxMat.subSurface.tintColor.g = 0.933;\n                  boxMat.subSurface.tintColor.b = 1.0;\n                  boxMat.subSurface.isScatteringEnabled = true;\n                  boxMat.subSurface.isTranslucencyEnabled = true;\n                  boxMat.disableDepthWrite = true\n      \n                  break;\n                case \"布尔\":\n                  mesh.visibility = 0\n                  boolBox = mesh as BABYLON.Mesh;\n                  break;\n                case \"柱体.001_Baked\":\n                  mesh.visibility = 0\n                  break;\n                case \"平面_primitive0\":\n                  mesh.visibility = 0\n                  water = mesh as BABYLON.Mesh;\n                  break;\n                case \"平面_primitive1\":\n                  mesh.visibility = 0\n                  waterWave = mesh as BABYLON.Mesh;\n                  break;\n                case \"边线_Baked\":\n                  mesh.visibility = 0\n                  break;\n                case \"立方体.011_Baked\":\n                  renderList.push(mesh)\n                  mesh.alphaIndex = 4\n                  // mesh.material.disableDepthWrite = true;\n                  mesh.material.alpha = 0.95\n                  mesh.material.alphaMode = BABYLON.Engine.ALPHA_MULTIPLY;\n                  mesh.material.transparencyMode = BABYLON.Material.MATERIAL_ALPHATEST;\n                  // (mesh.material as PBRMaterial).emissiveColor = Color3.FromInts(0.141,0, 0.482);\n                  (mesh.material as BABYLON.PBRMaterial).emissiveColor = BABYLON.Color3.FromInts(3.4,0, 51);\n                  (mesh.material as BABYLON.PBRMaterial).metallic = 1.0;\n                  (mesh.material as BABYLON.PBRMaterial).roughness = 0.0;\n                  break;\n                case \"立方体.013_Baked\":\n                  renderList.push(mesh)\n                  mesh.alphaIndex = 4\n                  // mesh.material.disableDepthWrite = true;\n                  mesh.material.alpha = 0.6\n                  mesh.material.alphaMode = BABYLON.Engine.ALPHA_MULTIPLY;\n                  mesh.material.transparencyMode = BABYLON.Material.MATERIAL_ALPHATEST;\n                  (mesh.material as BABYLON.PBRMaterial).emissiveColor = BABYLON.Color3.FromInts(12.6,0, 148);\n                  (mesh.material as BABYLON.PBRMaterial).metallic = 0.93;\n                  (mesh.material as BABYLON.PBRMaterial).roughness = 0.0;\n                  break;\n                case \"立方体.012_Baked\":\n                case \"立方体.014_Baked\":\n                  renderList.push(mesh)\n                  mesh.alphaIndex = 3\n                  mesh.material.alpha = 0.26\n                  mesh.material.transparencyMode = BABYLON.Material.MATERIAL_ALPHABLEND\n                  mesh.material.alphaMode = BABYLON.Engine.ALPHA_ADD;\n                  (mesh.material as BABYLON.PBRMaterial).emissiveColor = BABYLON.Color3.FromInts(0.059,0.161, 1.0);\n                  (mesh.material as BABYLON.PBRMaterial).metallic = 1.0;\n                  (mesh.material as BABYLON.PBRMaterial).roughness = 0.15;\n                  break;\n                case \"Cylinder\":\n                  break;\n                default:\n                  break;\n              }\n              }\n            })\n          })\n    }\n\n    protected async _run() {\n        // Get collision meshes\n        for (let i = 0; i < this._origCollisionPlanes.length; ++i) {\n            this._collisionPlanes.push(this._collisionObjects[i]);\n        }\n\n        this._collisionPlanes[this._collisionPlanes.length - 1][1].disabled = true;\n\n        // Reset camera\n        const camera = this._scene.activeCameras?.[0] ?? this._scene.activeCamera;\n        \n        const tempScene = new BABYLON.Scene(this._scene.getEngine());\n        const tempCamera = new BABYLON.ArcRotateCamera(\"camera\", 1.74, -0.0071, 10, BABYLON.Vector3.Zero(), tempScene);\n        tempCamera.lowerBetaLimit = -Math.PI * 2;\n        tempCamera.upperBetaLimit = Math.PI * 2;\n        tempCamera.lowerRadiusLimit = 1;\n        tempCamera.upperRadiusLimit = 1;\n        tempCamera.attachControl(document.getElementById(\"renderCanvas\"), true);\n        tempScene.attachControl(true,true,true);\n        tempScene.clearColor = new BABYLON.Color4(0, 0, 0, 0);\n        tempScene.autoClear = false\n\n        this._scene.onAfterCameraRenderObservable.add(() => {\n            tempScene.render()\n            if (this._customRootMesh) {\n                this._customRootMesh.rotationQuaternion = tempCamera.absoluteRotation;\n                this._rotateMeshes(-tempCamera.alpha, -tempCamera.beta);\n            }\n        })\n\n        if (camera) {\n            (camera as BABYLON.ArcRotateCamera).alpha = 1;\n            (camera as BABYLON.ArcRotateCamera).beta = 1.1;\n            (camera as BABYLON.ArcRotateCamera).radius = 1.9;\n            (camera as BABYLON.ArcRotateCamera).panningSensibility = 0;\n            (camera as BABYLON.ArcRotateCamera).lowerAlphaLimit = 1;\n            (camera as BABYLON.ArcRotateCamera).upperAlphaLimit = 1;\n            (camera as BABYLON.ArcRotateCamera).lowerBetaLimit = 1.1;\n            (camera as BABYLON.ArcRotateCamera).upperBetaLimit = 1.1;\n            (camera as BABYLON.ArcRotateCamera).lowerRadiusLimit = 1.9;\n            (camera as BABYLON.ArcRotateCamera).upperRadiusLimit = 1.9;\n\n            // camera.outputRenderTarget = new BABYLON.RenderTargetTexture(\n            //     \"rttFinal\",\n            //     {\n            //         width: this._engine.getRenderWidth(),\n            //         height: this._engine.getRenderHeight(),\n            //     },\n            //     this._scene\n            // );\n        }\n\n        // Simulation parameters\n        this._fluidRenderObject.object.particleSize = 0.08;\n        this._fluidRenderObject.object.particleThicknessAlpha = 0.103;\n\n        this._fluidSim!.smoothingRadius = 0.04;\n        this._fluidSim!.densityReference = 20000;\n        this._fluidSim!.pressureConstant = 4;\n        this._fluidSim!.viscosity = 0.01;\n        this._fluidSim!.maxVelocity = 6;\n        this._fluidSim!.maxAcceleration = 48000;\n\n        // Create materials\n        // this._boxMaterial = new BABYLON.PBRMaterial(\"BoxMeshMat\", this._scene);\n        // this._boxMaterial.metallic = 0.3;\n        // this._boxMaterial.roughness = 0;\n        // this._boxMaterial.alpha = 0.0;\n        // this._boxMaterial.backFaceCulling = true;\n        // this._boxMaterial.cullBackFaces = false;\n\n        // this._boxMaterialFront = this._boxMaterial.clone(\"BoxMeshFrontMat\");\n        // this._boxMaterialFront.cullBackFaces = true;\n\n        // Create meshes\n        // this._boxMesh = BABYLON.MeshBuilder.CreateBox(\n        //     \"boxMesh\",\n        //     {\n        //         width: this._boxMax.x - this._boxMin.x,\n        //         height: this._boxMax.y - this._boxMin.y,\n        //         depth: this._boxMax.z - this._boxMin.z,\n        //     },\n        //     this._scene\n        // );\n        // this._boxMesh.material = this._boxMaterial;\n        // this._boxMesh.position.x = (this._boxMin.x + this._boxMax.x) / 2;\n        // this._boxMesh.position.y = (this._boxMin.y + this._boxMax.y) / 2;\n        // this._boxMesh.position.z = (this._boxMin.z + this._boxMax.z) / 2;\n        // this._boxMesh.isPickable = false;\n\n        // this._boxMeshFront = this._boxMesh.clone(\"boxMeshFront\");\n        // this._boxMeshFront.material = this._boxMaterialFront;\n        // this._boxMeshFront.layerMask = 0x10000000; // make sure the mesh is not displayed by the camera - we will display it ourselves by a direct call to render()\n\n        // Render the front side of the box\n        // this._passPP.onApplyObservable.add((effect) => {\n        //     effect.setTexture(\"textureSampler\", camera!.outputRenderTarget);\n        // });\n\n        // let depthIsShared = false;\n        // this._sceneAfterCameraRenderObserver =\n        //     this._scene.onAfterCameraRenderObservable.add(() => {\n        //         const firstPP = camera?._getFirstPostProcess();\n        //         if (\n        //             firstPP &&\n        //             firstPP.inputTexture.depthStencilTexture &&\n        //             !depthIsShared\n        //         ) {\n        //             firstPP.inputTexture._shareDepth(\n        //                 camera!.outputRenderTarget!.renderTarget!\n        //             );\n        //             depthIsShared = true;\n        //         }\n        //         if (depthIsShared) {\n        //             this._boxMeshFront?.render(\n        //                 this._boxMeshFront.subMeshes[0],\n        //                 true\n        //             );\n        //             this._scene.postProcessManager.directRender(\n        //                 [this._passPP!],\n        //                 null\n        //             );\n        //         }\n        //     });\n\n        this._onEngineResizeObserver = this._engine.onResizeObservable.add(\n            () => {\n                camera?.outputRenderTarget?.resize({\n                    width: this._engine.getRenderWidth(true),\n                    height: this._engine.getRenderHeight(true),\n                });\n                // depthIsShared = false;\n            }\n        );\n\n        super._run();\n        setTimeout(() => {\n            document.getElementById(\"renderCanvas\")!.style.opacity = \"1.0\";\n        }, 800)\n    }\n\n    public dispose(): void {\n        super.dispose();\n\n        const camera =\n            this._scene.activeCameras?.[0] ?? this._scene.activeCamera;\n\n        if (camera) {\n            camera.outputRenderTarget?.dispose();\n            camera.outputRenderTarget = null;\n        }\n\n        this._scene.onBeforeRenderObservable.remove(this._sceneRenderObserver);\n        this._scene.onAfterCameraRenderObservable.remove(\n            this._sceneAfterCameraRenderObserver\n        );\n        this._scene.onKeyboardObservable.remove(this._sceneKeyboardObserver);\n\n        // this._passPP.dispose();\n        this._boxMesh?.dispose();\n        this._boxMeshFront?.dispose();\n        this._boxMaterial?.dispose();\n        this._engine.onResizeObservable.remove(this._onEngineResizeObserver);\n    }\n\n    protected _makeGUIMainMenu(): void {\n        const params = {\n            checkXZBounds: true,\n            autoRotateBox: false,\n            restart: () => {\n                this._angleX = this._angleY = 0;\n                this._autoRotateBox = false;\n                autoRotateBoxCtrl?.setValue(false);\n                this._rotateMeshes(0, 0);\n                this._generateParticles();\n            },\n            // boxOpacity: this._boxMaterial!.alpha,\n        };\n\n        const mainMenu = this._gui!;\n\n        let autoRotateBoxCtrl: BABYLON.Nullable<LiLGUI.Controller> = null;\n\n        mainMenu.add(params, \"restart\").name(\"Restart\");\n\n        mainMenu\n            .add(params, \"checkXZBounds\")\n            .name(\"Check box bounds\")\n            .onChange((value: boolean) => {\n                this._checkXZBounds = value;\n                this._boxMesh?.setEnabled(value);\n                this._boxMeshFront?.setEnabled(value);\n                for (let i = 0; i < this._collisionPlanes.length; ++i) {\n                    this._collisionPlanes[i][1].disabled =\n                        (!value && i < this._collisionPlanes.length - 1) ||\n                        (value && i === this._collisionPlanes.length - 1);\n                }\n                if (!value) {\n                    this._autoRotateBox = false;\n                    autoRotateBoxCtrl?.setValue(false);\n                }\n            });\n\n        autoRotateBoxCtrl = mainMenu\n            .add(params, \"autoRotateBox\")\n            .name(\"Auto rotate box\")\n            .onChange((value: boolean) => {\n                this._autoRotateBox = value;\n            });\n\n        // mainMenu\n        //     .add(params, \"boxOpacity\", 0, 1, 0.01)\n        //     .name(\"Box opacity\")\n        //     .onChange((value: any) => {\n        //         this._boxMaterial!.alpha = value;\n        //         this._boxMaterialFront!.alpha = value;\n        //     });\n    }\n\n    protected _onPaused(value: boolean) {\n        super._onPaused(value);\n\n        if (value) {\n            this._autoRotateBox = false;\n        }\n    }\n\n    protected _rotateMeshes(angleX: number, angleY: number): void {\n        const transfo = BABYLON.Matrix.RotationYawPitchRoll(\n            angleX,\n            0,\n            angleY,\n        );\n\n        const boxVertices = [\n            new BABYLON.Vector3(this._boxMin.x, this._boxMin.y, this._boxMin.z),\n            new BABYLON.Vector3(this._boxMin.x, this._boxMax.y, this._boxMin.z),\n            new BABYLON.Vector3(this._boxMin.x, this._boxMax.y, this._boxMax.z),\n            new BABYLON.Vector3(this._boxMin.x, this._boxMin.y, this._boxMax.z),\n            new BABYLON.Vector3(this._boxMax.x, this._boxMin.y, this._boxMin.z),\n            new BABYLON.Vector3(this._boxMax.x, this._boxMax.y, this._boxMin.z),\n            new BABYLON.Vector3(this._boxMax.x, this._boxMax.y, this._boxMax.z),\n            new BABYLON.Vector3(this._boxMax.x, this._boxMin.y, this._boxMax.z),\n        ];\n\n        let ymin = 1e10;\n        for (let i = 0; i < boxVertices.length; ++i) {\n            const v = BABYLON.Vector3.TransformCoordinates(\n                boxVertices[i],\n                transfo\n            );\n            ymin = Math.min(ymin, v.y);\n        }\n\n        this._collisionPlanes[\n            this._origCollisionPlanes.length - 1\n        ][1].params[1] = Math.abs(ymin) + 0.02;\n\n        for (let i = 0; i < this._origCollisionPlanes.length - 1; ++i) {\n            const plane = this._origCollisionPlanes[i].transform(transfo);\n            this._collisionPlanes[i][1].params = [plane.normal, plane.d];\n        }\n\n        const quat = BABYLON.Quaternion.FromRotationMatrix(transfo);\n\n        this._prevTransfo.invert();\n\n        if (this._sphereMesh) {\n            const tmp = BABYLON.Vector3.TransformCoordinates(\n                this._sphereMesh.position,\n                this._prevTransfo\n            );\n\n            this._sphereMesh.rotationQuaternion = quat;\n            this._sphereMesh.position = BABYLON.Vector3.TransformCoordinates(\n                tmp,\n                transfo\n            );\n        }\n\n        if (this._wallMesh) {\n            const tmp = BABYLON.Vector3.TransformCoordinates(\n                this._wallMesh.position,\n                this._prevTransfo\n            );\n\n            const m = BABYLON.Matrix.RotationYawPitchRoll(\n                0,\n                (90 * Math.PI) / 180,\n                0\n            );\n            const t = BABYLON.Matrix.Translation(tmp.x, tmp.y, tmp.z);\n\n            m.multiplyToRef(t, m).multiplyToRef(transfo, m);\n            const qf =\n                this._wallMesh.rotationQuaternion ?? new BABYLON.Quaternion();\n\n            m.decompose(undefined, qf, this._wallMesh.position);\n\n            this._wallMesh.rotationQuaternion = qf;\n        }\n\n        if (this._boxMesh && this._boxMeshFront) {\n            this._boxMesh.rotationQuaternion =\n                this._boxMeshFront.rotationQuaternion = quat;\n            this._boxMesh.position.x = (this._boxMin.x + this._boxMax.x) / 2;\n            this._boxMesh.position.y = (this._boxMin.y + this._boxMax.y) / 2;\n            this._boxMesh.position.z = (this._boxMin.z + this._boxMax.z) / 2;\n            this._boxMesh.position = BABYLON.Vector3.TransformCoordinates(\n                this._boxMesh.position,\n                transfo\n            );\n            this._boxMeshFront.position = this._boxMesh.position;\n        }\n\n        this._prevTransfo.copyFrom(transfo);\n    }\n}\n"],"names":["FluidSimulationDemoBoxSphere","FluidSimulationDemoBase","constructor","scene","super","_sphereMesh","_wallMesh","_customRootMesh","halfSize","this","_boxMin","_boxMax","_boxMesh","_boxMaterial","_boxMeshFront","_boxMaterialFront","_checkXZBounds","_origCollisionPlanes","Math","abs","z","x","y","_collisionPlanes","i","length","plane","addCollisionPlane","normal","d","undefined","_angleX","_angleY","_prevTransfo","_autoRotateBox","_sceneRenderObserver","_sceneAfterCameraRenderObserver","_sceneKeyboardObserver","_onEngineResizeObserver","loadCustomModel","_setCustomDebugLayer","debugKeyInfo","_scene","onKeyboardObservable","add","kbInfo","type","event","key","debugLayer","isVisible","hide","show","overlay","boolBox","water","waterWave","then","importResult","getMeshByName","scaling","set","lightConfig","intensity","diffuseColor","specularColor","position","lightNode","lights","forEach","light","index","pLight","parent","copyFrom","diffuse","specular","registerBeforeRender","rotationQuaternion","rotation","activeCameras","activeCamera","alpha","PI","renderList","meshes","mesh","name","material","alphaIndex","transparencyMode","alphaMode","boxMat","metallic","roughness","albedoColor","r","g","b","metallicReflectanceColor","anisotropy","isEnabled","sheen","color","useRoughnessFromMainTexture","subSurface","tintColor","isScatteringEnabled","isTranslucencyEnabled","disableDepthWrite","visibility","push","emissiveColor","async","_collisionObjects","disabled","camera","tempScene","getEngine","tempCamera","lowerBetaLimit","upperBetaLimit","lowerRadiusLimit","upperRadiusLimit","attachControl","document","getElementById","clearColor","autoClear","onAfterCameraRenderObservable","render","absoluteRotation","_rotateMeshes","beta","radius","panningSensibility","lowerAlphaLimit","upperAlphaLimit","_fluidRenderObject","object","particleSize","particleThicknessAlpha","_fluidSim","smoothingRadius","densityReference","pressureConstant","viscosity","maxVelocity","maxAcceleration","_engine","onResizeObservable","outputRenderTarget","resize","width","getRenderWidth","height","getRenderHeight","_run","setTimeout","style","opacity","dispose","onBeforeRenderObservable","remove","_makeGUIMainMenu","params","checkXZBounds","autoRotateBox","restart","autoRotateBoxCtrl","setValue","_generateParticles","mainMenu","_gui","onChange","value","setEnabled","_onPaused","angleX","angleY","transfo","boxVertices","ymin","v","min","transform","quat","invert","tmp","m","t","multiplyToRef","qf","decompose"],"sourceRoot":""}