{"version":3,"file":"731.356cac68ae4656f84604.js","mappings":"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","sources":["webpack://babylonjs-fluid-rendering/./src/scenes/FluidRenderer/fluidRenderingRenderTarget.ts"],"sourcesContent":["import * as BABYLON from \"@babylonjs/core\";\n\nexport class FluidRenderingRenderTarget {\n    protected _name: string;\n    protected _scene: BABYLON.Scene;\n    protected _camera: BABYLON.Nullable<BABYLON.Camera>;\n    protected _engine: BABYLON.Engine;\n    protected _width: number;\n    protected _height: number;\n    protected _blurTextureSizeX: number;\n    protected _blurTextureSizeY: number;\n    protected _textureType: number;\n    protected _textureFormat: number;\n    protected _blurTextureType: number;\n    protected _blurTextureFormat: number;\n    protected _useStandardBlur: boolean;\n    protected _generateDepthBuffer: boolean;\n    protected _samples: number;\n    protected _postProcessRunningIndex: number;\n\n    protected _rt: BABYLON.Nullable<BABYLON.RenderTargetWrapper>;\n    protected _texture: BABYLON.Nullable<BABYLON.Texture>;\n    protected _rtBlur: BABYLON.Nullable<BABYLON.RenderTargetWrapper>;\n    protected _textureBlurred: BABYLON.Nullable<BABYLON.Texture>;\n    protected _blurPostProcesses: BABYLON.Nullable<BABYLON.PostProcess[]>;\n\n    public enableBlur = true;\n\n    public blurSizeDivisor = 1;\n\n    public blurFilterSize = 7;\n\n    private _blurNumIterations = 3;\n\n    public get blurNumIterations() {\n        return this._blurNumIterations;\n    }\n\n    public set blurNumIterations(numIterations: number) {\n        if (this._blurNumIterations === numIterations) {\n            return;\n        }\n\n        this._blurNumIterations = numIterations;\n        if (this._blurPostProcesses !== null) {\n            const blurX = this._blurPostProcesses[0];\n            const blurY = this._blurPostProcesses[1];\n\n            this._blurPostProcesses = [\n                ...Array(this._blurNumIterations * 2).keys(),\n            ].map((elm) => (elm & 1 ? blurY : blurX));\n        }\n    }\n\n    public blurMaxFilterSize = 100;\n\n    public blurDepthScale = 10;\n\n    public particleSize = 0.02;\n\n    public onDisposeObservable: BABYLON.Observable<FluidRenderingRenderTarget> =\n        new BABYLON.Observable<FluidRenderingRenderTarget>();\n\n    public get renderTarget() {\n        return this._rt;\n    }\n\n    public get renderTargetBlur() {\n        return this._rtBlur;\n    }\n\n    public get texture() {\n        return this._texture;\n    }\n\n    public get textureBlur() {\n        return this._textureBlurred;\n    }\n\n    constructor(\n        name: string,\n        scene: BABYLON.Scene,\n        width: number,\n        height: number,\n        blurTextureSizeX: number,\n        blurTextureSizeY: number,\n        textureType: number = BABYLON.Constants.TEXTURETYPE_FLOAT,\n        textureFormat: number = BABYLON.Constants.TEXTUREFORMAT_R,\n        blurTextureType: number = BABYLON.Constants.TEXTURETYPE_FLOAT,\n        blurTextureFormat: number = BABYLON.Constants.TEXTUREFORMAT_R,\n        useStandardBlur = false,\n        camera: BABYLON.Nullable<BABYLON.Camera> = null,\n        generateDepthBuffer = true,\n        samples = 1\n    ) {\n        this._name = name;\n        this._scene = scene;\n        this._camera = camera;\n        this._engine = scene.getEngine();\n        this._width = width;\n        this._height = height;\n        this._blurTextureSizeX = blurTextureSizeX;\n        this._blurTextureSizeY = blurTextureSizeY;\n        this._textureType = textureType;\n        this._textureFormat = textureFormat;\n        this._blurTextureType = blurTextureType;\n        this._blurTextureFormat = blurTextureFormat;\n        this._useStandardBlur = useStandardBlur;\n        this._generateDepthBuffer = generateDepthBuffer;\n        this._samples = samples;\n        this._postProcessRunningIndex = 0;\n        this.enableBlur = blurTextureSizeX !== 0 && blurTextureSizeY !== 0;\n\n        this._rt = null;\n        this._texture = null;\n        this._rtBlur = null;\n        this._textureBlurred = null;\n        this._blurPostProcesses = null;\n    }\n\n    public initialize(): void {\n        this.dispose();\n\n        this._createRenderTarget();\n\n        if (this.enableBlur && this._texture) {\n            const [rtBlur, textureBlurred, blurPostProcesses] =\n                this._createBlurPostProcesses(\n                    this._texture,\n                    this._blurTextureType,\n                    this._blurTextureFormat,\n                    this.blurSizeDivisor,\n                    this._name,\n                    this._useStandardBlur\n                );\n            this._rtBlur = rtBlur;\n            this._textureBlurred = textureBlurred;\n            this._blurPostProcesses = blurPostProcesses;\n        }\n    }\n\n    public applyBlurPostProcesses(): void {\n        if (this.enableBlur && this._blurPostProcesses) {\n            this._postProcessRunningIndex = 0;\n            this._scene.postProcessManager.directRender(\n                this._blurPostProcesses,\n                this._rtBlur,\n                true\n            );\n            this._engine.unBindFramebuffer(this._rtBlur!);\n        }\n    }\n\n    protected _createRenderTarget(): void {\n        this._rt = this._engine.createRenderTargetTexture(\n            { width: this._width, height: this._height },\n            {\n                generateMipMaps: false,\n                type: this._textureType,\n                format: this._textureFormat,\n                samplingMode: BABYLON.Constants.TEXTURE_NEAREST_SAMPLINGMODE,\n                generateDepthBuffer: this._generateDepthBuffer,\n                generateStencilBuffer: false,\n                samples: this._samples,\n            }\n        );\n\n        const renderTexture = this._rt.texture!;\n\n        this._texture = new BABYLON.Texture(null, this._scene);\n        this._texture.name = \"rtt\" + this._name;\n        this._texture._texture = renderTexture;\n        this._texture.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;\n        this._texture.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;\n        this._texture.anisotropicFilteringLevel = 1;\n    }\n\n    protected _createBlurPostProcesses(\n        textureBlurSource: BABYLON.ThinTexture,\n        textureType: number,\n        textureFormat: number,\n        blurSizeDivisor: number,\n        debugName: string,\n        useStandardBlur = false\n    ): [BABYLON.RenderTargetWrapper, BABYLON.Texture, BABYLON.PostProcess[]] {\n        const engine = this._scene.getEngine();\n        const targetSize = new BABYLON.Vector2(\n            Math.floor(this._blurTextureSizeX / blurSizeDivisor),\n            Math.floor(this._blurTextureSizeY / blurSizeDivisor)\n        );\n        const useBilinearFiltering =\n            (textureType === BABYLON.Constants.TEXTURETYPE_FLOAT &&\n                engine.getCaps().textureFloatLinearFiltering) ||\n            (textureType === BABYLON.Constants.TEXTURETYPE_HALF_FLOAT &&\n                engine.getCaps().textureHalfFloatLinearFiltering);\n\n        const rtBlur = this._engine.createRenderTargetTexture(\n            { width: targetSize.x, height: targetSize.y },\n            {\n                generateMipMaps: false,\n                type: textureType,\n                format: textureFormat,\n                samplingMode: useBilinearFiltering\n                    ? BABYLON.Constants.TEXTURE_BILINEAR_SAMPLINGMODE\n                    : BABYLON.Constants.TEXTURE_NEAREST_SAMPLINGMODE,\n                generateDepthBuffer: false,\n                generateStencilBuffer: false,\n                samples: this._samples,\n            }\n        );\n\n        const renderTexture = rtBlur.texture!;\n\n        const texture = new BABYLON.Texture(null, this._scene);\n        texture.name = \"rttBlurred\" + debugName;\n        texture._texture = renderTexture;\n        texture.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;\n        texture.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;\n        texture.anisotropicFilteringLevel = 1;\n\n        if (useStandardBlur) {\n            const kernelBlurXPostprocess = new BABYLON.PostProcess(\n                \"BilateralBlurX\",\n                \"standardBlur\",\n                [\"filterSize\", \"blurDir\"],\n                null,\n                1,\n                null,\n                BABYLON.Constants.TEXTURE_NEAREST_SAMPLINGMODE,\n                engine,\n                true,\n                null,\n                textureType,\n                undefined,\n                undefined,\n                undefined,\n                textureFormat\n            );\n            kernelBlurXPostprocess.samples = this._samples;\n            kernelBlurXPostprocess.externalTextureSamplerBinding = true;\n            kernelBlurXPostprocess.onApplyObservable.add((effect) => {\n                if (this._postProcessRunningIndex === 0) {\n                    effect.setTexture(\"textureSampler\", textureBlurSource);\n                } else {\n                    effect._bindTexture(\n                        \"textureSampler\",\n                        kernelBlurXPostprocess.inputTexture.texture\n                    );\n                }\n                effect.setInt(\"filterSize\", this.blurFilterSize);\n                effect.setFloat2(\"blurDir\", 1 / this._blurTextureSizeX, 0);\n                this._postProcessRunningIndex++;\n            });\n            kernelBlurXPostprocess.onSizeChangedObservable.add(() => {\n                kernelBlurXPostprocess._textures.forEach((rt) => {\n                    rt.texture!.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;\n                    rt.texture!.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;\n                });\n            });\n            this._fixReusablePostProcess(kernelBlurXPostprocess);\n\n            const kernelBlurYPostprocess = new BABYLON.PostProcess(\n                \"BilateralBlurY\",\n                \"standardBlur\",\n                [\"filterSize\", \"blurDir\"],\n                null,\n                1,\n                null,\n                BABYLON.Constants.TEXTURE_NEAREST_SAMPLINGMODE,\n                engine,\n                true,\n                null,\n                textureType,\n                undefined,\n                undefined,\n                undefined,\n                textureFormat\n            );\n            kernelBlurYPostprocess.samples = this._samples;\n            kernelBlurYPostprocess.onApplyObservable.add((effect) => {\n                effect.setInt(\"filterSize\", this.blurFilterSize);\n                effect.setFloat2(\"blurDir\", 0, 1 / this._blurTextureSizeY);\n                this._postProcessRunningIndex++;\n            });\n            kernelBlurYPostprocess.onSizeChangedObservable.add(() => {\n                kernelBlurYPostprocess._textures.forEach((rt) => {\n                    rt.texture!.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;\n                    rt.texture!.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;\n                });\n            });\n            this._fixReusablePostProcess(kernelBlurYPostprocess);\n\n            kernelBlurXPostprocess.autoClear = false;\n            kernelBlurYPostprocess.autoClear = false;\n\n            return [\n                rtBlur,\n                texture,\n                [...Array(this._blurNumIterations * 2).keys()].map((elm) =>\n                    elm & 1 ? kernelBlurYPostprocess : kernelBlurXPostprocess\n                ),\n            ];\n        } else {\n            const uniforms: string[] = [\n                \"maxFilterSize\",\n                \"blurDir\",\n                \"projectedParticleConstant\",\n                \"depthThreshold\",\n            ];\n\n            const kernelBlurXPostprocess = new BABYLON.PostProcess(\n                \"BilateralBlurX\",\n                \"bilateralBlur\",\n                uniforms,\n                null,\n                1,\n                null,\n                BABYLON.Constants.TEXTURE_NEAREST_SAMPLINGMODE,\n                engine,\n                true,\n                null,\n                textureType,\n                undefined,\n                undefined,\n                undefined,\n                textureFormat\n            );\n            kernelBlurXPostprocess.samples = this._samples;\n            kernelBlurXPostprocess.externalTextureSamplerBinding = true;\n            kernelBlurXPostprocess.onApplyObservable.add((effect) => {\n                if (this._postProcessRunningIndex === 0) {\n                    effect.setTexture(\"textureSampler\", textureBlurSource);\n                } else {\n                    effect._bindTexture(\n                        \"textureSampler\",\n                        kernelBlurXPostprocess.inputTexture.texture\n                    );\n                }\n                effect.setInt(\"maxFilterSize\", this.blurMaxFilterSize);\n                effect.setFloat2(\"blurDir\", 1 / this._blurTextureSizeX, 0);\n                effect.setFloat(\n                    \"projectedParticleConstant\",\n                    this._getProjectedParticleConstant()\n                );\n                effect.setFloat(\"depthThreshold\", this._getDepthThreshold());\n                this._postProcessRunningIndex++;\n            });\n            kernelBlurXPostprocess.onSizeChangedObservable.add(() => {\n                kernelBlurXPostprocess._textures.forEach((rt) => {\n                    rt.texture!.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;\n                    rt.texture!.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;\n                });\n            });\n            this._fixReusablePostProcess(kernelBlurXPostprocess);\n\n            const kernelBlurYPostprocess = new BABYLON.PostProcess(\n                \"BilateralBlurY\",\n                \"bilateralBlur\",\n                uniforms,\n                null,\n                1,\n                null,\n                BABYLON.Constants.TEXTURE_NEAREST_SAMPLINGMODE,\n                engine,\n                true,\n                null,\n                textureType,\n                undefined,\n                undefined,\n                undefined,\n                textureFormat\n            );\n            kernelBlurYPostprocess.samples = this._samples;\n            kernelBlurYPostprocess.onApplyObservable.add((effect) => {\n                effect.setInt(\"maxFilterSize\", this.blurMaxFilterSize);\n                effect.setFloat2(\"blurDir\", 0, 1 / this._blurTextureSizeY);\n                effect.setFloat(\n                    \"projectedParticleConstant\",\n                    this._getProjectedParticleConstant()\n                );\n                effect.setFloat(\"depthThreshold\", this._getDepthThreshold());\n                this._postProcessRunningIndex++;\n            });\n            kernelBlurYPostprocess.onSizeChangedObservable.add(() => {\n                kernelBlurYPostprocess._textures.forEach((rt) => {\n                    rt.texture!.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;\n                    rt.texture!.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;\n                });\n            });\n            this._fixReusablePostProcess(kernelBlurYPostprocess);\n\n            kernelBlurXPostprocess.autoClear = false;\n            kernelBlurYPostprocess.autoClear = false;\n\n            return [\n                rtBlur,\n                texture,\n                [...Array(this._blurNumIterations * 2).keys()].map((elm) =>\n                    elm & 1 ? kernelBlurYPostprocess : kernelBlurXPostprocess\n                ),\n            ];\n        }\n    }\n\n    private _fixReusablePostProcess(pp: BABYLON.PostProcess) {\n        if (!pp.isReusable()) {\n            return;\n        }\n\n        pp.onActivateObservable.add(() => {\n            // undo what calling activate() does which will make sure we will retrieve the right texture when getting the input for the post process\n            pp._currentRenderTextureInd = (pp._currentRenderTextureInd + 1) % 2;\n        });\n        pp.onApplyObservable.add(() => {\n            // now we can advance to the next texture\n            pp._currentRenderTextureInd = (pp._currentRenderTextureInd + 1) % 2;\n        });\n    }\n\n    private _getProjectedParticleConstant() {\n        return (\n            (this.blurFilterSize *\n                this.particleSize *\n                0.05 *\n                (this._height / 2)) /\n            Math.tan((this._camera?.fov ?? (45 * Math.PI) / 180) / 2)\n        );\n    }\n\n    private _getDepthThreshold() {\n        return (this.particleSize / 2) * this.blurDepthScale;\n    }\n\n    public dispose(): void {\n        if (this.onDisposeObservable.hasObservers()) {\n            this.onDisposeObservable.notifyObservers(this);\n        }\n\n        this._rt?.dispose();\n        this._rt = null;\n        this._rtBlur?.dispose();\n        this._rtBlur = null;\n        if (this._blurPostProcesses) {\n            this._blurPostProcesses[0].dispose();\n            this._blurPostProcesses[1].dispose();\n        }\n        this._blurPostProcesses = null;\n    }\n}\n"],"names":["FluidRenderingRenderTarget","constructor","name","scene","width","height","blurTextureSizeX","blurTextureSizeY","textureType","textureFormat","blurTextureType","blurTextureFormat","useStandardBlur","camera","generateDepthBuffer","samples","enableBlur","blurSizeDivisor","blurFilterSize","_blurNumIterations","blurMaxFilterSize","blurDepthScale","particleSize","onDisposeObservable","this","_name","_scene","_camera","_engine","getEngine","_width","_height","_blurTextureSizeX","_blurTextureSizeY","_textureType","_textureFormat","_blurTextureType","_blurTextureFormat","_useStandardBlur","_generateDepthBuffer","_samples","_postProcessRunningIndex","_rt","_texture","_rtBlur","_textureBlurred","_blurPostProcesses","blurNumIterations","numIterations","blurX","blurY","Array","keys","map","elm","renderTarget","renderTargetBlur","texture","textureBlur","initialize","dispose","_createRenderTarget","rtBlur","textureBlurred","blurPostProcesses","_createBlurPostProcesses","applyBlurPostProcesses","postProcessManager","directRender","unBindFramebuffer","createRenderTargetTexture","generateMipMaps","type","format","samplingMode","generateStencilBuffer","renderTexture","wrapU","wrapV","anisotropicFilteringLevel","textureBlurSource","debugName","engine","targetSize","Math","floor","useBilinearFiltering","getCaps","textureFloatLinearFiltering","textureHalfFloatLinearFiltering","x","y","kernelBlurXPostprocess","undefined","externalTextureSamplerBinding","onApplyObservable","add","effect","setTexture","_bindTexture","inputTexture","setInt","setFloat2","onSizeChangedObservable","_textures","forEach","rt","_fixReusablePostProcess","kernelBlurYPostprocess","autoClear","uniforms","setFloat","_getProjectedParticleConstant","_getDepthThreshold","pp","isReusable","onActivateObservable","_currentRenderTextureInd","tan","fov","PI","hasObservers","notifyObservers"],"sourceRoot":""}